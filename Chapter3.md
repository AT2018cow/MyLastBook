# 理念、原则、定律与微服务设计

当我们谈及理念的时候，一般指期望按照某个理想的方式做事，而执行过程中，则有可能因为各种客观因素的限制，导致这种期望无法达成；而原则则不同：原则是必须达成的理念，在执行过程中，需要设立规章制度、流程、工具链等措施，确保原则可以达成。在实际工作中，明确理念和原则的区别至关重要：达成理念，会带来好的结果，应该奖励，不能达成，也不是什么太大的问题，下次再努力即可；遵守原则，是分内之事，违反原则，会带来坏的结果，应该惩罚。当然，结果的好坏，是个相对的概念，与投入的时间、资本、人员等诸多因素有关，某种意义上，一个组织的进步，就是把优秀的理念逐渐变成原则的过程。

在实际工作中，理念可以是感性的和鼓舞人心的，而原则则必须是：

* 措辞明确的：必须明确阐述该怎样做和达到什么样的目标，以作为实际工作的指导方针；
* 现实可达的：必须是在付出一定努力之后可以实现的，制定难以实现的原则，除了不具备指导实践的意义之外，还可能会打击团队士气；
* 可度量的：必须是量化的，实际工作中，不能只说“接口简洁”，还要将简洁的程度加以量化，例如，“接口数量小于m个”、“参数数量小于n个”、等等；
* 可检验的：实际工作中，如果提出原则，那么必须可以对原则的达成情况进行检验，不能检验达成情况的原则极易落入空谈；

与原则相关的另一个概念是定律（也称法则），人们经常混淆这两个概念，尤其是在翻译文章中。实际上，原则和定律是两个完全相反的概念，原则是“经过一定努力可以达到的”，定律是“经过再多努力也难以违背的”。定律一般会陈述一种“宿命般”的现象，也可能是一个假言命题：如果你的状况不幸落入假言命题的前件，那么绝大多情况下，你将面对该假言命题的后件所描述的糟糕结局。

下文我们会介绍一些与微服务开发密切相关的理念、原则和定律。

## 理念

早期的操作系统进程生成代价昂贵，缺乏灵活易用的进程控制机制。例如上个世纪七、八十年代广为流行的VAX VMS系统，启动进程开销极大、速度缓慢并且需要特别的权限，同时，这类操作系统缺乏灵活的进程间通讯机制，难以通过多个进程的协作实现应用功能，这些问题迫使开发者编写怪物般的巨大单体应用，将越来越多的功能和特性塞入单个程序之中，久而久之，怪物般的应用像怪物般失控，或者因不堪重负而内部崩溃。Unix操作系统的出现，带来了低价的进程生成能力和简便的进程间通讯机制，使得编写多个功能单一的小程序，并通过管道和过滤器彼此协作、组成一个均衡系统成为可能。

Unix致力于降低进程生成的开销、提供多种方法简化进程间通讯、并提倡使用能够由管道和套接字传递的简单、透明的文本格式数据，从而鼓励开发者将大型程序分解成多个协作进程，鼓励每个进程“做单件事并做好”的设计风格，从而使大型程序结构简单、功能强大、稳定可靠。这就是Unix最具特点的模块化程序设计方法，在历史上被称为“多道程序设计”。随着Unix的流行，这种编程方式一度成为开发复杂应用的默认方式，以至于时不时的出现这样的笑话：

>Unix新手：“我关闭了音乐播放器，为什么音乐还在响？”
>Unix老手：“你关闭的只是播放器的图形界面，并不是播放器的引擎。”
>Unix新手：“……”

发生这样的事情，显然是因为播放器的界面和后端的解码器是两个进程，通过进程间通讯机制彼此协作，共同完成一个完整的音乐播放器功能。这种设计很多好处，例如：

1. 开发者可以开发多个不同风格的界面，并且很容易的将一个界面换成另外一个。
1. 开发者可以调用不同的后端解码器，以支持不同的音频格式，引入新的音频格式，或者换掉现有的解码器，也非常简单。
1. 社区已经有很多成熟的解码器，拿来用即可，使得播放器的开发变得非常简单。
1. 界面与解码器可以使用不同的语言开发，即可以用最适合的语言开发各个独立的程序模块。

当然，一个设计良好的音乐播放器，在图形界面被关闭的时候，是可以发消息通知后端的解码器将自己关闭的（或者也可以使用现代Unix的Init系统配置进程依赖关系，将图形界面和后端程序同时关闭）。但是即使不是这样，在Unix世界生存的人们也对其习以为常，可见这种开发模式的普遍性。即使是到了今天，当你在OS X的终端应用里退出Shell的时候，终端应用的图形界面也不会随之关闭，不是吗？

平价的进程生成和简单的进程控制对多道程序设计至关重要，可惜多年以后，Java语言开始流行，JVM屏蔽了底层操作系统的差异，开发者在大多数时间只要和JVM打交道，即可完成手头的工作，操作系统变得无足轻重，操作系统的优秀机制对软件开发带来的便利性也逐渐淡出开发者的视线。遗憾的是，JVM并没有提供类似Unix的进程管理和通讯能力，使得开发者再次倾向于编写怪物般的巨大单体应用，在Java应用服务器出现之后，这种情况没有得到改观，反而愈演愈烈，将多个应用运行在同一个应用服务器之上，形成了无比巨大的单一Java进程，一个微小的Bug都可能造成进程退出，其上的所有应用都无法继续使用，而代码错综复杂的巨大单体应用，出现这种Bug的概率非常之高。这种巨大单体应用的维护成本高昂，哪怕是对其进行必要的更新也变得非常困难，这种应用就像恐龙一样，摄入的能量无法维持自身庞大的身躯，等待它的结局只能是衰亡。

曾经有段时间，业界寄希望于将类似Unix的进程控制和进程通讯能力引入JVM，但是这种工作的复杂度无异于将JVM变成一个操作系统，随着云计算、PaaS等技术的流行，业界开始试图通过另外一种途径解决问题，即微服务模式。

微服务模式提倡每个微服务专注于单一责任与功能，利用模块化的方式组装出复杂的大型应用，微服务之间默认通过REST API和文本格式的数据流通讯以彼此协作，并搭建微服务平台对微服务的进程进行管理调度。微服务模式面对的问题和解决问题的方式都像极了Unix世界的传统理念，甚至可以认为微服务模式就是Unix多道程序设计模式在Web领域和分布式系统下的进一步扩展，难怪Unix程序员在看到业界鼓吹微服务时，不屑一顾的耸了耸肩膀：“难道不是一直都这样做的吗？”

所以在讨论微服务的设计理念时，我们有必要先回顾一下Unix多道程序设计所提倡的一些理念。技术人员似乎都不愿意回顾历史，尤其是，软件行业的历史只有短短的几十年，回顾如此短暂的历史，似乎远没有展望充满无限可能的未来更加有趣，所以软件行业重复的犯错，有道是“忘记过去的人注定要重蹈覆辙”。

### 理念一：做单件事并做好

程序应该只做一件事并将其做好（Do One Thing and Do It Well），“只做一件事”指的是程序的功能要单一，如果要实现多个功能，那就编写多个程序，提倡“制作多把专用的刀，而不是一把瑞士军刀”，“将其做好”指的是日后程序都要围绕这个单一功能进行优化。这个理念的提出者一般被认为是道格拉斯·麦克罗伊（Douglas McIlroy）。这个理念有时候也被称为模块原则，不过正如前文所述，在本章的上下文中，原则应该是措辞明确和可度量的，而什么样的事情算是“单件事”、“事情”的边界如何划分？这都需要在具体场景下才能得到明确的定义，所以我们还是将其列为理念。各位读者可能没有听说过道格拉斯·麦克罗伊，但想必一定听说过软件工业的神级人物、Unix的关键开发者、1983年的图灵奖得主——丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson），而道格拉斯·麦克罗伊正是这两位神级人物的领导。在1965年至1986年间，道格拉斯·麦克罗伊在贝尔实验室的计算机技术研发部门做了二十一年主管，这个部门最著名的事迹就是研发了Unix操作系统，丹尼斯·里奇和肯·汤普森正是这个部门的员工。同时，道格拉斯·麦克罗伊还被认为是Unix管道的发明人和Unix核心理念的奠基人。这个理念的原文是：

>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。

这个理念看起来很简单，可是知易行难，什么样的事情算是“一件事”、什么样的任务算是“新任务”？这和在开发什么样的应用、应用开发到了哪个阶段、应用使用者的数量等诸多因素密切相关。举例来说，开发一个在线视频网站，“登录”显然可以看作是“一件事”，如果使用微服务模式，那么可以把“登录服务”作为一个微服务来开发。随着网站规模的增长、用户数量越来越大，网站开始支持多种设备访问，比如电脑、手机、平板电脑、机顶盒等设备，还有Xbox、PlayStation等游戏机。由于来自每种设备的用户数量都十分巨大，这些设备的登录方式和登录界面又存在着较大的差异，“来自不同设备的登录”变成了此时的“一件事”，“登录服务”这一个微服务被拆分成了“电脑登录”、“手机登录”、“平板电脑登录”等多个微服务，由于几代PlayStation的系统差异较大，支持PlayStation访问的登录服务还可以进一步拆分为“PS2登录服务”、“PS3登录服务”、“PS4登录服务”等……这样做的另一个好处是，来自各种设备的登录用户数量差异巨大，例如来自手机的登录用户数可能是来自PlayStation 3的登录用户数的数十倍、来自PlayStation 2的登录用户数的上百倍，如果把对多种设备登录的支持都放在一个微服务里，那与登录用户数较小的设备有关的代码就白白占用了资源。说到这里，有些读者可能发现了一个新问题，那就是支持不同设备登录的微服务里，还有很多共性的功能，比如填写验证码、找回密码等功能，在这些微服务里，几乎是一模一样的，那么每个微服务都去开发一套填写验证码和找回密码功能，显然是不合理的，这个时候，“填写验证码”变成了“一件事”，“找回密码”变成了另外“一件事”，这两件事情也需要被拆分出来，变成独立的微服务，供各种登录微服务调用。

由此可见，如何划分“一件事”，这个问题还是比较复杂的，相比本地应用，Web应用的划分方式会更加复杂。本地应用在做出合理的模块划分之后，在应用的整个生命周期中可能都不会再做改变，而Web应用的划分合理性是相对的，在生命周期的不同阶段，会有不同的最适划分方式，在这个问题上，传统的应用模块划分经验不会有太多帮助，后面我们会在“AKF扩展立方”中进一步讨论这个问题。

### 理念二：协作优先，文本通讯

在程序的设计初期就要考虑协作，即程序必须能够与其他程序进行拼接组合。假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的，同时在输入输出方面，尽可能使用简单的、文本化的、面向流的格式，因为如果程序不采用简单的文本流做输入和输出，它们就极难衔接。首先文本格式对不同的操作系统和编程语言是一致的，即“天然支持异构系统集成”，其次文本流接口的简洁性加强了程序的封装性，充当了理想的阻隔点，防止程序的实现细节彼此泄露。不管在程序内部，使用了怎样的数据类型和数据结构，数据之间有多么复杂的逻辑关系，在将它们输出的时候，都将被转换为文本流，这个文本流在作为另一个程序的输入时，该程序可以按照自己的数据组织方式将文本流转换成特定的数据类型和数据结构。这样一来，两个程序的内部状态就被完全隔离了，而许多精致的进程间通讯方式，比如远程过程调用（RPC），都存在牵扯过多各程序内部状态的倾向。远程过程调用提供多种数据类型和数据结构，调用两端的程序需要对数据类型和数据结构进行匹配，容易产生匹配错误或者版本不兼容等问题，如果使用二进制格式传递数据，则会让接口变得更加晦涩和难以使用。

使用文本流接口还有一个潜在益处，那就是迫使开发者设计粗粒度的接口。一般情况下开发人员倾向于设计细粒度的接口，例如想要查询五十件商品的价格和库存，那就分别查询每一件商品的价格和库存，再重复五十次，这在进程内没有问题，但是如果是跨进程的调用，则最好将其转化成一次性的批量调用，一次性的获得这五十件商品的价格和库存，尤其是在这种调用要经过网络的时候。因为进程内的调用速度很快而且调用总是成功（指调用本身不会失败，而不是其他的程序错误），而跨进程的调用速度则慢了很多，如果是经过网络的跨主机调用，则会慢几个数量级，由于网络连接可能出现故障，调用可能失败，如果使用细粒度的接口，错误的恢复和脏数据的清理也会比较麻烦。

Web应用开发领域也经历了类似的过程，早期的二进制RPC使用者寥寥，随后出现的XML-RPC将RPC和Unix对文本流的坚持以一种有趣的方式融合到一起，将调用编码为XML，并通过HTTP协议传输，综合了RPC和文本流的优点，开始获得了比较广泛的应用。XML-RPC在获得了初步的成功之后，开始不断的引入新功能，慢慢演变成了SOAP协议（Simple Object Access Protocol）。SOAP协议有着明显的“第二系统效应”[注1]，不久之后业界便转向了更为简洁的REST模式（Representational State Transfer，表述性状态传递），并随着微服务一起发扬光大。

_注1：第二系统效应指的是，在一个小型、优雅的系统获得成功之后，人们开始对这个系统的第二个版本产生了过多的期待、引入了过多的功能和假设，即“过度设计”，导致系统过于庞大和复杂，并因此而失败）。_

在微服务“思潮”的早期，来自微软的Juval Löwy曾提出：“服务通过类似Unix管道（Unix-like pipelines）的方式拼接组合，复杂的服务被抽象为简单的URI接口（Uniform Resource Identifier，统一资源标识符）。”那么现在REST模式就是Juval Löwy所说的Unix-like pipelines。需要注意的是，REST模式只是一种设计风格，而不是与XML-RPC和SOAP对等的协议，REST模式将对服务的调用抽象为对资源的操作，使用URI标识资源，使用JSON、YAML等文本流表述和传递资源状态，使用GET、PUT、POST、DELETE等标准的HTTP方法操作资源。REST模式没有一个正式的标准，但是却有一套复杂而完备的理念，后面我们会对其进行单独的讨论。

### 理念三：不要传播错误

程序在发生错误的时候不应该有不可知的行为，更不应该传递混乱的信息，影响与之协作的其他程序。最理想的情况当然是能够应付非正常的操作，但是如果在不能应付的情况下，却不声不响的继续执行，埋下隐患，或者将错误继续传递给后端，直到很久以后才显现出来，则是最坏的一种情况。尤其是在微服务模式下，一个业务功能经常由多级微服务调用共同完成，如果错误在调用链中逐级积累，容易引起雪崩效应，小错误变成大范围的故障。因此，程序要尽可能的应付错误的输入和自身的运行错误，并且在不能应付的情况下及时终止，并输出详细的错误信息以供排错。不要将错误继续传递到调用链的下一环节。

在微服务模式下，除了小心翼翼的编写代码之外，还需要提供一些必要的机制进行故障隔离，防止错误传播。典型的机制有：

* 限流：当突发的请求高峰到来时，需要有限流机制防止处理能力耗尽。如果后台还有空闲资源，系统可以趁这个机会创建更多的微服务实例，提高处理能力，再将限流停止。除了突发的请求高峰之外，程序Bug、硬件故障和缓存失效等原因，也会使微服务的处理能力突然下降，触发限流。在微服务模式下，限流之所以非常重要，是因为被调用方的不可用，很可能会造成调用方的不可用，并在调用链上逐级放大，引起服务雪崩。常见的限流方式有直接拒绝服务、排队等待、直接返回默认数据等，还有控制重试的时间间隔、尽量避免同步调用等辅助措施。
* 降级：与限流相比，降级更贴近于业务层面。降级指关闭部分业务功能，以保障主体业务功能可用。降级的原因可能是业务高峰时资源不足，需要通过关闭非核心业务功能，为核心业务功能腾出资源，以保障核心业务功能可用；也可能是后台微服务发生故障，导致与其相关的业务功能被迫关闭。例如，除夕夜大家都在微信上抢红包，这时候微信钱包的一些功能，如微粒贷、理财通和生活缴费，可能就会被关闭，因为很少有人会在这个时候去贷款、买理财产品和缴水电费，可以暂时关闭这些业务，为这个时候的核心业务“抢红包”腾出资源；再例如，在线商店在某个支付渠道发生故障时，可以直接将这个支付渠道对应的菜单置灰，用户可以选择其他的支付渠道继续购物，此时如果不对支付功能做降级处理，则可能会导致整个支付功能被挂起，用户就无法愉快的买买买了。
* 熔断：熔断机制类似电路断路器，电路断路器在电路发生过载或者短路的时候自动切断电路，以保护电路上的电器不被损坏，熔断机制则在微服务过载或者网络连接缓慢的时候中断请求的进一步进入，以防止请求堆积导致资源耗尽，引发雪崩效应。设计良好的熔断机制还可以提供故障检测能力，在故障恢复的时候自动终止熔断。

上述三种机制并不泾渭分明，而是互有交叉，实践中也经常需要配合使用，其根本目的都是为了进行故障隔离、防止错误传播。Netflix Hystrix就是一个同时提供这三种机制的优秀开源项目，在本书的第五章会对其进行详细的介绍。

上面回顾了古老的Unix多道程序设计中与微服务关系最为密切的三个理念，并在微服务模式下对其进行了扩展，接下来的几个理念则与微服务诞生于同一时代。

### 理念四：持续交付

持续交付（Continuous Delivery）旨在更加密集的构建、测试和发布软件，密集到如果业务需要，则每一次修改都可以即时发布到生产环境。这么做的目的是：

* 降低交付风险：由于每次只交付较小的更新，出现错误的可能性也较小，即使出现错误，也可以及时修复或者将更新回滚。
* 及时验证开发结果：开发完成并不意味着真的完成，交付到生产环境并且可用，才意味着真的完成。
* 及时获得用户反馈：每个较小的更新都可以及时被用户使用，并获得反馈信息，从而及时确认每个更新的业务价值，及时调整接下来的开发计划，获得更好的业务敏捷性。

微服务模式极大的促进了持续交付理念的实践。单体应用由于以下原因，极难进行持续交付：

* 编译时间过长：意味着很难为每一次更新都做编译。
* 测试流程复杂：更新之后要对整个应用进行全面测试，因为一次较小的更新而执行全面测试，投入产出比太低。
* 部署开销过大：类似于上一个原因，因为一次较小的更新就把整个应用重新部署一次，业务风险很大。

但是微服务模式成功的避免了上述问题：

* 微服务的代码规模较小，可以快速完成编译。
* 微服务的功能内聚性较强，测试开销较小，也容易自动化。
* 微服务易于部署，而且微服务都是采用多实例方式部署，可以先更新小部分实例，即采用金丝雀发布[注2]，测试通过后再逐个更新其他实例，业务风险很小。

_注2：金丝雀发布（Canary Release）指在真实的生产环境下对更新进行小范围测试，如果测试通过则进行大范围更新，如果测试失败则将小范围的更新回滚到上一个版本。这么做的意义在于可以发现测试环境中不容易发现的问题，同时将问题限制在一个较小的范围。金丝雀发布这个名称的由来是，早期矿工下矿井的时候都会带着一只金丝雀，如果矿井中出现有毒气体，金丝雀会首先察觉，为矿工创造逃脱时间。_

### 理念五：不可变服务器

不可变服务器（Immutable Server）指的是，服务器（包含虚拟机、容器和之上的应用程序）在上线之后，就不要对其做任何修改（包括修改配置、升级或者打补丁等），如果需要修改，就创建新的服务器替换现有的服务器。实践这一理念至少需要两个前置条件：

* 应用程序无状态：不可变服务器本地不可存储状态数据，如会话、缓存、日志等，都需要存储在外部服务中。这么做的理由显而易见：如果这些数据存储在服务器内部，那么对服务器进行替换的时候，这些数据就会丢失。
* 使用模板部署：使用模板可以快速的批量部署服务器，同时使用模板库对模板进行“版本管理”，这样对线上环境的每次变更都会被记录在案。使用容器模板部署是首选方案，例如可以使用Jenkins将代码和运行环境编译为Docker镜像并部署。使用虚拟机模板也可以达到类似的目的，但是虚拟机模板体积过大，存储和传输虚拟机模板都会带来极大的开销，同时虚拟机模板还缺少单一的模板制作和管理工具，实施过程中还可能会遇到Hypervisor适配、驱动更新等琐碎问题，这些问题累积起来导致使用虚拟机模板部署举步维艰。另外，使用Puppet、Chef等配置管理工具也可以实现服务器的快速部署，但是编写和测试配置管理脚本会带来很大的额外工作量。

不可变服务器带来的好处是：

* 易于跟踪线上变化：由于运行在线上的服务器都由模板创建，而且创建之后就不会再被修改，所以线上的运行的每个服务器都可以在模板库里找到“真身”，并且使用同一个模板创建的所有服务器都是一模一样的。如果允许直接修改线上服务器，那么随着时间的推移，这些服务器将会进入某种不可预知的状态，即，谁也说不清楚这些服务器上到底被修改了些什么，这种情况一般被称为配置“漂移”或者“蚀变”；此时同一用途的一组服务器，例如一个业务集群，也必然会陷入不一致的状态，而不一致的集群会给运维带来很多麻烦，例如难以对其进行批量操作，因为同一个操作在不同的服务器上可能会产生不一致的后果，同时也很难保证部署在这样的集群上的应用的每个节点会有一致的表现，在集群规模很大的时候这简直就是一场灾难。很多公司会通过文档和管理流程记录线上服务器的每一次修改，或者采购变更管理软件对线上服务器的修改做统一管理，但是有什么能比根本不去修改来的更加简单呢？
* 易于恢复故障：如果线上服务器发生故障，那么可以使用对应的模板迅速完成重新部署；如果是模板本身的问题，那么可以通过部署前一个运行正常的模板替换问题服务器，快速完成回退。如果直接对线上服务器进行修改，一旦引发故障，很有可能无法实现回退，因为根本不知道服务器之前的状态是什么！

### 理念六：运用声明式思想

声明式思想源自编程泛型概念，即声明式编程（Declarative Programming，有时候也被翻译成申明式或者宣告式），意思是告诉计算机完成任务的目标，然后让计算机自行选择执行路径到达目标。与其相对应的是命令式编程（Imperative Programming，有时候也被翻译成指令式），意思是告诉计算机完成任务的各个步骤，然后计算机按照既定步骤执行。两种编程模式几乎诞生于同一年代，但是在随后的几十年中，命令式编程始终占据绝对主流。直到2009年之后，随着多核处理器和并行计算的兴起，由于声明式编程可以大大降低并行程序的编写难度，该模式才开始得到了业界的高度关注。

如果声明指的是针对任务目标的声明，那么所有通用编程语言都是命令式的，原因很简单：计算机无法自动完成所有任务。如果限制在某个具体的领域，实现一个针对任务目标的声明式语言则会相对比较容易：枚举这个领域的所有任务目标，然后根据一系列规则得到到达这些任务目标的执行路径。

函数式编程语言虽然也被认为是声明式的，但是也只是过程中的声明，并不是针对任务目标的声明。

很多著名的领域专用语言（DSL）都是声明式的，原因也很简单：在某些特定的问题域，




“声明式”有时也被成为“描述式”或者“申明式”，为告诉计算机你想要什么，“声明”你想要的what，由计算机自己去设计执行路径，需要计算机或者是“运行时”具备一定的“智能”。在这种情况下，计算机显然不会实现所有你想要的what，套用术语说就是“非图灵完备”，但是针对特定的任务，“声明式”要远比“命令式”方便，其实大多数声明式语言都是针对特定任务的领域专用语言，即DSL。当然，随着深度学习驱动的自动编程技术的兴起，我们有可能在任意领域使用“声明式”完成任务，这是后话，暂且不提。

最常见的声明式语言就是SQL —— 告诉计算机你想要的结果集，SQL语言的运行时，即数据库，帮你设计获取这个结果集的执行路径，并返回结果集。众所周知，使用SQL语言获取数据，要比自行编写处理过程去获取数据容易的多。

下面是一个最简单的例子：

4

在这个例子里我们可以看到，使用其他通用语言“命令式”的完成查询，要比使用SQL语言“声明式”的完成查询复杂的多。在数据量很大的时候两种方法的复杂度差距会更加明显，数据库可以帮助你收集数据分布的统计信息、维护索引和选择最佳执行路径，以保证查询性能，如果你自行编码完成这些工作，那代码量会有成千上万行。

“声明式”虽然为一个编程语言的概念，但是也可以上升到一个比较高的层面，作为一个设计软件的思想或思路，就好像你可以使用“命令式”的C语言，编写一个可以“声明式”使用的数据库一样。

但是我们很少使用“声明式”思想去设计软件。下面是我能想到的几个原因：

5

最重要的原因是第三个，归纳和提取完备的what，是件很困难、很技术化的工作，令人望而却步。

但是在很多特定的领域，我们往往更加喜欢实现“声明式”思想的工具，比如前面提到的SQL语言。

6

原因也很简单，因为这些工具的编写者，已经把实践“声明式”思想的最大障碍 —— 归纳和提取what，替你完成了。

现在我们跳出编程的概念，看下“声明式”思想在系统和微服务架构的运维还有DevOps等领域的应用。

首先看一个运维故事：

7

再看另外一个运维故事：

8

开个小玩笑，这里不是黑Puppet，也不是鼓吹Docker，我想表达的是，如果你以“命令式”的思路，编写一个过程化的脚本去部署应用，很可能会发生意想不到的事情，造成部署失败；而如果以“声明式”的思路，去制作和部署一个Docker镜像，那么成功率将大大提高。当然，Puppet也支持“声明式”，Docker也可以按“命令式”去使用，比如不太友好的Entrypoint脚本，但是这些都不是重点。

重点是，如果使用“命令式”思路去部署一个分布式系统或者微服务架构，已经变得非常困难。

比如部署下面这个系统：

9

“命令式”运维存在着下述问题，这些问题在分布式系统和微服务架构中日趋严重。

10

在分布式系统和微服务架构中，edge case更加复杂，环境更加动态，想在脚本中处理这些问题，你需要成为一个事无巨细的绝顶高手。如果同时还想实现部署结果的一致性、事务性和版本化，那简直是不可能完成的任务，就好像只是为了查询一笔数据，却要去编写一个数据库。

如果使用“声明式”的思路，问题则简单的多：

11

“声明式”运维的表现，就是编写一个配置文件，描述想要的部署结果，然后由平台解析这个配置文件并自动生成这个部署结果。描述部署结果的配置文件比过程化的脚本更加易于理解，可以由开发人员自行编写。由开发人员参与的Ops，才叫DevOps。

配置文件一目了然，多人维护不是问题，有错误也很容易被发现。配置文件本身就是文档。部署结果为配置文件所描述，如果达不到这个结果，那么部署失败并回退到部署之前的状态，所以部署天然具备了一致性和事务性。

当然，上述优势需要专用平台去保证，Kubernetes就是这样的一个平台。

接下来就以Kubernetes为例，说明一下平台软件的“声明式”设计思想。

Kubernetes非常强调声明式思想，在其文档的第一篇就明确提出：

12

使用Kubernetes时，用户不需要去定义do A then B then C这种workflow，而是直接去描述一个desired state，然后Kubernetes帮助用户去达到这个state。至于如何达到这个state，用户不必关心。这种设计使Kubernetes更加易用和健壮，更具弹性和扩展性。

在Kubernetes的设计原则中，也把Declarative列在首位。

13

State your desired results, let the system actuate.

Kubernetes实现了多个Control Loop，观测系统的运行状态，如果偏离了预期状态，Kubernetes会自动进行校正。

14

举一个简单的例子，Kubernetes会维护一个集群系统内的可用节点数，使其等于用户的定义数量，如果有节点发生故障，Kubernetes会自行产生新节点替换故障节点，以保证可用节点数不变。

15

“声明式”思想在分布式系统和微服务架构中如此重要，所以我们的一位英国小伙伴在办公桌上钉了这样一个纸条时刻提醒自己：

16

可是说归说，做归做，我们该如何去实践“声明式”思想呢？

普元将“声明式”思想贯彻到了数字化企业云平台的开发工作中，与此同时，普元还有一个秘密武器，普元前些年做了一个很牛的元数据管理产品，现在把它用在了声明信息的管理上，以高效管理声明信息，帮助实现大规模分布式系统和微服务架构的“声明式”运维工作。

17

最后，我们有一个One More Thing，是声明式思想的一个延伸概念 —— Choreography。

18

在前面提到的What is Kubernetes文档中，说“Kubernetes不仅是一个orchestration system”，而是“more akin to choreography”。那么orchestration和choreography这两个概念代表什么呢？

Orchestration的本意是乐队指挥：

19

Choreography的本意是舞蹈编舞：

20

这两个概念的最大区别就是，乐队指挥是个中央控制点，而舞蹈中是不存在这样一个控制点的 —— 舞蹈演员根据舞伴的动作来确定自己的下一个动作。

这两个概念用到IT中，也是非常的贴切，差异就在系统中有无乐队指挥那样的中央控制点。

21

可以看到，Orchestration是由一个中央引擎执行一个工作流，来达到一个预期状态，更贴近“命令式”概念；而Choreography则定义了交互协议 —— 参与方根据相关方的动作来确定自己的下一个动作，来达到一个预期状态，更贴近“声明式”概念。

所以在What is Kubernetes中，特别强调Kubernetes的实践思路是more akin to choreography。

顺便提一下，很多文章将Orchestration翻译为“编排”，其实并不准确。

在大规模的分布式系统和微服务架构中，是很难实现一个“上帝视角”的中央控制点的，所以在实践“声明式”思想的时候，要时刻记得choreography。

今天的分享就到这里，谢谢大家。

22




## 原则

### 12 Factor

### C4 SPOT原则

### AKF扩展立方

## 定律

### 定律一：侯世达定律

道格拉斯·理查·郝夫斯台特（Douglas Richard Hofstadter），美国印第安纳大学文理学院认知科学教授，主要研究领域包括意识、类比、艺术创造、文学翻译以及数学和物理学探索，侯世达是他的中文名。这位看起来和软件行业关系不大的学者（他本人也说“对计算机没有兴趣”），其普利策奖著作《哥德尔、埃舍尔、巴赫》中的一句格言却在软件行业广为流传，这句格言被称为侯世达定律（Hofstadter's Law）：

>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。

侯世达定律指出完成复杂任务需要花费的时间总是很难预计。这个定律经常被软件开发人员提起，特别是在进行项目计划的讨论时。定律使用自指方式（或者说是递归）表述了即使充分意识到了任务的复杂性，仍然难以准确预计完成任务所需时间的窘境。

即使使用微服务模式开发你的应用，侯世达定律依然有效，因为在评估开发所需时间的时候，你已经将微服务模式带来的效率提高考虑在内了，不是吗？

### 定律二：90-90定律

90-90定律（Ninety-ninety Rule）是软件行业又一个有名的定律，源自贝尔实验室专家汤姆·卡吉尔（Tom Cargill）的一句玩笑话：

>前90%的代码要花费90%的开发时间，剩余的10%的代码要再花费90%的开发时间。

合计180%的时间总量用看似荒诞的方式指出了软件项目的一个顽疾——项目完成时间常常大幅超出预期。这个定律体现了在评估软件项目完成时间的时候，对简单任务和困难任务的时间分配太过粗糙的问题，也揭示了很多项目被迫延期的原因：最后10%的工作的难度，是前90%工作的难度的9倍（如果不是10倍或以上的话）。

### 定律三：布鲁克斯定律

是的，这个布鲁克斯就是IBM System/360系统之父和软件工程著作《人月神华》的作者弗雷德·布鲁克斯（Fred Brooks）。布鲁克斯定律（Brook's Law）的内容是：

>给一个延期的项目增加人手会使它拖得更久。

弗雷德·布鲁克斯在《人月神话》中提出了这一定律，并对其成立的原因做出了如下解释：

1. 新加入项目的人员需要学习一段时间才会有产出，教会他们反而会占用团队中老成员的时间。
1. 人员数量增加，沟通成本也会增加，最糟糕的情况下是指数级增加。
1. 任务的有限可分性：一些任务不可分割，增加人手不能使任务完成的更快。

那项目延期了怎么办？弗雷德·布鲁克斯给出的办法是：降低项目目标。

### 定律四：埃托雷观察

埃托雷观察（Ettorre's Observation）的内容是：

>另外一条路看起来会走得更快。

软件项目中存在大量的路径选择问题，大到选择一个技术方向，小到选择一个具体问题的解决方案，当我们在已选的路径上遇到困难时，经常会觉得之前如果选择另一条路径，事情会更加顺利。这种想法经常会导致个人的犹豫不决和团队成员之间的不信任，最终影响项目的整体进度。然而另一条路径很可能只是看起来更加顺利而已，因为你在实践当前路径，对当前路径中会碰到的问题有着更多的了解，而另一条路径仅存于你的想象之中，你“幻想”它好的一面，却不了解它坏的一面。如果你真的切换到另一条路径，八成你又会觉得之前那条路径会更加顺利，这就是“埃托雷观察”，永远的“另外一条路看起来会走得更快”。

所以，在软件项目中，做路径选择的时候要充分验证，一旦确定路径，就不要因为遇到的困难而犹豫不决。

### 定律五：康威定律


