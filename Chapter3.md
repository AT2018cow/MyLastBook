# 理念、原则、定律与微服务设计

当我们谈及理念的时候，一般指期望按照某个理想的方式做事，而执行过程中，则有可能因为各种客观因素的限制，导致这种期望无法达成；而原则则不同：原则是必须达成的理念，在执行过程中，需要设立规章制度、流程、工具链等措施，确保原则可以达成。在实际工作中，明确理念和原则的区别至关重要：达成理念，会带来好的结果，应该奖励，不能达成，也不是什么太大的问题，下次再努力即可；遵守原则，是分内之事，违反原则，会带来坏的结果，应该惩罚。当然，结果的好坏，是个相对的概念，与投入的时间、资本、人员等诸多因素有关，某种意义上，一个组织的进步，就是把优秀的理念逐渐变成原则的过程。

在实际工作中，理念可以是感性的和鼓舞人心的，而原则则必须是：

* 措辞明确的：必须明确阐述该怎样做和达到什么样的目标，以作为实际工作的指导方针；
* 现实可达的：必须是在付出一定努力之后可以实现的，制定难以实现的原则，除了不具备指导实践的意义之外，还可能会打击团队士气；
* 可度量的：必须是量化的，实际工作中，不能只说“接口简洁”，还要将简洁的程度加以量化，例如，“接口数量小于m个”、“参数数量小于n个”、等等；
* 可检验的：实际工作中，如果提出原则，那么必须可以对原则的达成情况进行检验，不能检验达成情况的原则极易落入空谈；

与原则相关的另一个概念是定律（也称法则），人们经常混淆这两个概念，尤其是在翻译文章中。实际上，原则和定律是两个完全相反的概念，原则是“经过一定努力可以达到的”，定律是“经过再多努力也难以违背的”。定律一般会陈述一种“宿命般”的现象，也可能是一个假言命题：如果你的状况不幸落入假言命题的前件，那么绝大多情况下，你将面对该假言命题的后件所描述的糟糕结局。

下文我们会介绍一些与微服务开发密切相关的理念、原则和定律。

## 理念

早期的操作系统进程生成代价昂贵，缺乏灵活易用的进程控制机制。例如上个世纪七、八十年代广为流行的VAX VMS系统，启动进程开销极大、速度缓慢并且需要特别的权限，同时，这类操作系统缺乏灵活的进程间通讯机制，难以通过多个进程的协作实现应用功能，这些问题迫使开发者编写怪物般的巨大单体应用，将越来越多的功能和特性塞入单个程序之中，久而久之，怪物般的应用像怪物般失控，或者因不堪重负而内部崩溃。Unix操作系统的出现，带来了低价的进程生成能力和简便的进程间通讯机制，使得编写多个功能单一的小程序，并通过管道和过滤器彼此协作、组成一个均衡系统成为可能。

Unix致力于降低进程生成的开销、提供多种方法简化进程间通讯、并提倡使用能够由管道和套接字传递的简单、透明的文本格式数据，从而鼓励开发者将大型程序分解成多个协作进程，鼓励每个进程“做单件事并做好”的设计风格，从而使大型程序结构简单、功能强大、稳定可靠。这就是Unix最具特点的模块化程序设计方法，在历史上被称为“多道程序设计”。随着Unix的流行，这种编程方式一度成为开发复杂应用的默认方式，以至于时不时的出现这样的笑话：

>Unix新手：“我关闭了音乐播放器，为什么音乐还在响？”
>Unix老手：“你关闭的只是播放器的图形界面，并不是播放器的引擎。”
>Unix新手：“……”

发生这样的事情，显然是因为播放器的界面和后端的解码器是两个进程，通过进程间通讯机制彼此协作，共同完成一个完整的音乐播放器功能。这种设计很多好处，例如：

1. 开发者可以开发多个不同风格的界面，并且很容易的将一个界面换成另外一个。
1. 开发者可以调用不同的后端解码器，以支持不同的音频格式，引入新的音频格式，或者换掉现有的解码器，也非常简单。
1. 社区已经有很多成熟的解码器，拿来用即可，使得播放器的开发变得非常简单。
1. 界面与解码器可以使用不同的语言开发，即可以用最适合的语言开发各个独立的程序模块。

当然，一个设计良好的音乐播放器，在图形界面被关闭的时候，是可以发消息通知后端的解码器将自己关闭的（或者也可以使用现代Unix的Init系统配置进程依赖关系，将图形界面和后端程序同时关闭）。但是即使不是这样，在Unix世界生存的人们也对其习以为常，可见这种开发模式的普遍性。即使是到了今天，当你在OS X的终端应用里退出Shell的时候，终端应用的图形界面也不会随之关闭，不是吗？

平价的进程生成和简单的进程控制对多道程序设计至关重要，可惜多年以后，Java语言开始流行，JVM屏蔽了底层操作系统的差异，开发者在大多数时间只要和JVM打交道，即可完成手头的工作，操作系统变得无足轻重，操作系统的优秀机制对软件开发带来的便利性也逐渐淡出开发者的视线。遗憾的是，JVM并没有提供类似Unix的进程管理和通讯能力，使得开发者再次倾向于编写怪物般的巨大单体应用，在Java应用服务器出现之后，这种情况没有得到改观，反而愈演愈烈，将多个应用运行在同一个应用服务器之上，形成了无比巨大的单一Java进程，一个微小的Bug都可能造成进程退出，其上的所有应用都无法继续使用，而代码错综复杂的巨大单体应用，出现这种Bug的概率非常之高。这种巨大单体应用的维护成本高昂，哪怕是对其进行必要的更新也变得非常困难，这种应用就像恐龙一样，摄入的能量无法维持自身庞大的身躯，等待它的结局只能是衰亡。

曾经有段时间，业界寄希望于将类似Unix的进程控制和进程通讯能力引入JVM，但是这种工作的复杂度无异于将JVM变成一个操作系统，随着云计算、PaaS等技术的流行，业界开始试图通过另外一种途径解决问题，即微服务模式。

微服务模式提倡每个微服务专注于单一责任与功能，利用模块化的方式组装出复杂的大型应用，微服务之间默认通过REST API和文本格式的数据流通讯以彼此协作，并搭建微服务平台对微服务的进程进行管理调度。微服务模式面对的问题和解决问题的方式都像极了Unix世界的传统理念，甚至可以认为微服务模式就是Unix多道程序设计模式在Web领域和分布式系统下的进一步扩展，难怪Unix程序员在看到业界鼓吹微服务时，不屑一顾的耸了耸肩膀：“难道不是一直都这样做的吗？”

所以在讨论微服务的设计理念时，我们有必要先回顾一下Unix多道程序设计所提倡的一些理念。技术人员似乎都不愿意回顾历史，尤其是，软件行业的历史只有短短的几十年，回顾如此短暂的历史，似乎远没有展望充满无限可能的未来更加有趣，所以软件行业重复的犯错，有道是“忘记过去的人注定要重蹈覆辙”。

### 理念一：做单件事并做好

程序应该只做一件事并将其做好（Do One Thing and Do It Well），“只做一件事”指的是程序的功能要单一，如果要实现多个功能，那就编写多个程序，提倡“制作多把专用的刀，而不是一把瑞士军刀”，“将其做好”指的是日后程序都要围绕这个单一功能进行优化。这个理念的提出者一般被认为是道格拉斯·麦克罗伊（Douglas McIlroy）。这个理念有时候也被称为模块原则，不过正如前文所述，在本章的上下文中，原则应该是措辞明确和可度量的，而什么样的事情算是“单件事”、“事情”的边界如何划分？这都需要在具体场景下才能得到明确的定义，所以我们还是将其列为理念。各位读者可能没有听说过道格拉斯·麦克罗伊，但想必一定听说过软件工业的神级人物、Unix的关键开发者、1983年的图灵奖得主——丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson），而道格拉斯·麦克罗伊正是这两位神级人物的领导。在1965年至1986年间，道格拉斯·麦克罗伊在贝尔实验室的计算机技术研发部门做了二十一年主管，这个部门最著名的事迹就是研发了Unix操作系统，丹尼斯·里奇和肯·汤普森正是这个部门的员工。同时，道格拉斯·麦克罗伊还被认为是Unix管道的发明人和Unix核心理念的奠基人。这个理念的原文是：

>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。

这个理念看起来很简单，可是知易行难，什么样的事情算是“一件事”、什么样的任务算是“新任务”？这和在开发什么样的应用、应用开发到了哪个阶段、应用使用者的数量等诸多因素密切相关。举例来说，开发一个在线视频网站，“登录”显然可以看作是“一件事”，如果使用微服务模式，那么可以把“登录服务”作为一个微服务来开发。随着网站规模的增长、用户数量越来越大，网站开始支持多种设备访问，比如电脑、手机、平板电脑、机顶盒等设备，还有Xbox、PlayStation等游戏机。由于来自每种设备的用户数量都十分巨大，这些设备的登录方式和登录界面又存在着较大的差异，“来自不同设备的登录”变成了此时的“一件事”，“登录服务”这一个微服务被拆分成了“电脑登录”、“手机登录”、“平板电脑登录”等多个微服务，由于几代PlayStation的系统差异较大，支持PlayStation访问的登录服务还可以进一步拆分为“PS2登录服务”、“PS3登录服务”、“PS4登录服务”等……这样做的另一个好处是，来自各种设备的登录用户数量差异巨大，例如来自手机的登录用户数可能是来自PlayStation 3的登录用户数的数十倍、来自PlayStation 2的登录用户数的上百倍，如果把对多种设备登录的支持都放在一个微服务里，那与登录用户数较小的设备有关的代码就白白占用了资源。说到这里，有些读者可能发现了一个新问题，那就是支持不同设备登录的微服务里，还有很多共性的功能，比如填写验证码、找回密码等功能，在这些微服务里，几乎是一模一样的，那么每个微服务都去开发一套填写验证码和找回密码功能，显然是不合理的，这个时候，“填写验证码”变成了“一件事”，“找回密码”变成了另外“一件事”，这两件事情也需要被拆分出来，变成独立的微服务，供各种登录微服务调用。

由此可见，如何划分“一件事”，这个问题还是比较复杂的，相比本地应用，Web应用的划分方式会更加复杂。本地应用在做出合理的模块划分之后，在应用的整个生命周期中可能都不会再做改变，而Web应用的划分合理性是相对的，在生命周期的不同阶段，会有不同的最适划分方式，在这个问题上，传统的应用模块划分经验不会有太多帮助，后面我们会在“AKF扩展立方”中进一步讨论这个问题。

### 理念二：协作优先，文本通讯

在程序的设计初期就要考虑协作，即程序必须能够与其他程序进行拼接组合。假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的，同时在输入输出方面，尽可能使用简单的、文本化的、面向流的格式，因为如果程序不采用简单的文本流做输入和输出，它们就极难衔接。首先文本格式对不同的操作系统和编程语言是一致的，即“天然支持异构系统集成”，其次文本流接口的简洁性加强了程序的封装性，充当了理想的阻隔点，防止程序的实现细节彼此泄露。不管在程序内部，使用了怎样的数据类型和数据结构，数据之间有多么复杂的逻辑关系，在将它们输出的时候，都将被转换为文本流，这个文本流在作为另一个程序的输入时，该程序可以按照自己的数据组织方式将文本流转换成特定的数据类型和数据结构。这样一来，两个程序的内部状态就被完全隔离了，而许多精致的进程间通讯方式，比如远程过程调用（RPC），都存在牵扯过多各程序内部状态的倾向。远程过程调用提供多种数据类型和数据结构，调用两端的程序需要对数据类型和数据结构进行匹配，容易产生匹配错误或者版本不兼容等问题，如果使用二进制格式传递数据，则会让接口变得更加晦涩和难以使用。

使用文本流接口还有一个潜在益处，那就是迫使开发者设计粗粒度的接口。一般情况下开发人员倾向于设计细粒度的接口，例如想要查询五十件商品的价格和库存，那就分别查询每一件商品的价格和库存，再重复五十次，这在进程内没有问题，但是如果是跨进程的调用，则最好将其转化成一次性的批量调用，一次性的获得这五十件商品的价格和库存，尤其是在这种调用要经过网络的时候。因为进程内的调用速度很快而且调用总是成功（指调用本身不会失败，而不是其他的程序错误），而跨进程的调用速度则慢了很多，如果是经过网络的跨主机调用，则会慢几个数量级，由于网络连接可能出现故障，调用可能失败，如果使用细粒度的接口，错误的恢复和脏数据的清理也会比较麻烦。

Web应用开发领域也经历了类似的过程，早期的二进制RPC使用者寥寥，随后出现的XML-RPC将RPC和Unix对文本流的坚持以一种有趣的方式融合到一起，将调用编码为XML，并通过HTTP协议传输，综合了RPC和文本流的优点，开始获得了比较广泛的应用。XML-RPC在获得了初步的成功之后，开始不断的引入新功能，慢慢演变成了SOAP协议（Simple Object Access Protocol）。SOAP协议有着明显的“第二系统效应”[注1]，不久之后业界便转向了更为简洁的REST模式（Representational State Transfer，表述性状态传递），并随着微服务一起发扬光大。

_注1：第二系统效应指的是，在一个小型、优雅的系统获得成功之后，人们开始对这个系统的第二个版本产生了过多的期待、引入了过多的功能和假设，即“过度设计”，导致系统过于庞大和复杂，并因此而失败。_

在微服务“思潮”的早期，来自微软的Juval Löwy曾提出：“服务通过类似Unix管道（Unix-like pipelines）的方式拼接组合，复杂的服务被抽象为简单的URI接口（Uniform Resource Identifier，统一资源标识符）。”那么现在REST模式就是Juval Löwy所说的Unix-like pipelines。需要注意的是，REST模式只是一种设计风格，而不是与XML-RPC和SOAP对等的协议，REST模式将对服务的调用抽象为对资源的操作，使用URI标识资源，使用JSON、YAML等文本流表述和传递资源状态，使用GET、PUT、POST、DELETE等标准的HTTP方法操作资源。REST模式没有一个正式的标准，但是却有一套复杂而完备的理念，后面我们会对其进行单独的讨论。

### 理念三：不要传播错误

程序在发生错误的时候不应该有不可知的行为，更不应该传递混乱的信息，影响与之协作的其他程序。最理想的情况当然是能够应付非正常的操作，但是如果在不能应付的情况下，却不声不响的继续执行，埋下隐患，或者将错误继续传递给后端，直到很久以后才显现出来，则是最坏的一种情况。尤其是在微服务模式下，一个业务功能经常由多级微服务调用共同完成，如果错误在调用链中逐级积累，容易引起雪崩效应，小错误变成大范围的故障。因此，程序要尽可能的应付错误的输入和自身的运行错误，并且在不能应付的情况下及时终止，并输出详细的错误信息以供排错。不要将错误继续传递到调用链的下一环节。

在微服务模式下，除了小心翼翼的编写代码之外，还需要提供一些必要的机制进行故障隔离，防止错误传播。典型的机制有：

* 限流：当突发的请求高峰到来时，需要有限流机制防止处理能力耗尽。如果后台还有空闲资源，系统可以趁这个机会创建更多的微服务实例，提高处理能力，再将限流停止。除了突发的请求高峰之外，程序Bug、硬件故障和缓存失效等原因，也会使微服务的处理能力突然下降，触发限流。在微服务模式下，限流之所以非常重要，是因为被调用方的不可用，很可能会造成调用方的不可用，并在调用链上逐级放大，引起服务雪崩。常见的限流方式有直接拒绝服务、排队等待、直接返回默认数据等，还有控制重试的时间间隔、尽量避免同步调用等辅助措施。
* 降级：与限流相比，降级更贴近于业务层面。降级指关闭部分业务功能，以保障主体业务功能可用。降级的原因可能是业务高峰时资源不足，需要通过关闭非核心业务功能，为核心业务功能腾出资源，以保障核心业务功能可用；也可能是后台微服务发生故障，导致与其相关的业务功能被迫关闭。例如，除夕夜大家都在微信上抢红包，这时候微信钱包的一些功能，如微粒贷、理财通和生活缴费，可能就会被关闭，因为很少有人会在这个时候去贷款、买理财产品和缴水电费，可以暂时关闭这些业务，为这个时候的核心业务“抢红包”腾出资源；再例如，在线商店在某个支付渠道发生故障时，可以直接将这个支付渠道对应的菜单置灰，用户可以选择其他的支付渠道继续购物，此时如果不对支付功能做降级处理，则可能会导致整个支付功能被挂起，用户就无法愉快的买买买了。
* 熔断：熔断机制类似电路断路器，电路断路器在电路发生过载或者短路的时候自动切断电路，以保护电路上的电器不被损坏，熔断机制则在微服务过载或者网络连接缓慢的时候中断请求的进一步进入，以防止请求堆积导致资源耗尽，引发雪崩效应。设计良好的熔断机制还可以提供故障检测能力，在故障恢复的时候自动终止熔断。

上述三种机制并不泾渭分明，而是互有交叉，实践中也经常需要配合使用，其根本目的都是为了进行故障隔离、防止错误传播。Netflix Hystrix就是一个同时提供这三种机制的优秀开源项目，在本书的第五章会对其进行详细的介绍。

上面回顾了古老的Unix多道程序设计中与微服务关系最为密切的三个理念，并在微服务模式下对其进行了扩展，接下来的几个理念则与微服务诞生于同一时代。

### 理念四：持续交付

持续交付（Continuous Delivery）旨在更加密集的构建、测试和发布软件，密集到如果业务需要，则每一次修改都可以即时发布到生产环境。这么做的目的是：

* 降低交付风险：由于每次只交付较小的更新，出现错误的可能性也较小，即使出现错误，也可以及时修复或者将更新回滚。
* 及时验证开发结果：开发完成并不意味着真的完成，交付到生产环境并且可用，才意味着真的完成。
* 及时获得用户反馈：每个较小的更新都可以及时被用户使用，并获得反馈信息，从而及时确认每个更新的业务价值，及时调整接下来的开发计划，获得更好的业务敏捷性。

微服务模式极大的促进了持续交付理念的实践。单体应用由于以下原因，极难进行持续交付：

* 编译时间过长：意味着很难为每一次更新都做编译。
* 测试流程复杂：更新之后要对整个应用进行全面测试，因为一次较小的更新而执行全面测试，投入产出比太低。
* 部署开销过大：类似于上一个原因，因为一次较小的更新就把整个应用重新部署一次，业务风险很大。

但是微服务模式成功的避免了上述问题：

* 微服务的代码规模较小，可以快速完成编译。
* 微服务的功能内聚性较强，测试开销较小，也容易自动化。
* 微服务易于部署，而且微服务都是采用多实例方式部署，可以先更新小部分实例，即采用金丝雀发布[注2]，测试通过后再逐个更新其他实例，业务风险很小。

_注2：金丝雀发布（Canary Release）指在真实的生产环境下对更新进行小范围测试，如果测试通过则进行大范围更新，如果测试失败则将小范围的更新回滚到上一个版本。这么做的意义在于可以发现测试环境中不容易发现的问题，同时将问题限制在一个较小的范围。金丝雀发布这个名称的由来是，早期矿工下矿井的时候都会带着一只金丝雀，如果矿井中出现有毒气体，金丝雀会首先察觉，为矿工创造逃脱时间。_

### 理念五：不可变服务器

不可变服务器（Immutable Server）指的是，服务器（包含虚拟机、容器和之上的应用程序）在上线之后，就不要对其做任何修改（包括修改配置、升级或者打补丁等），如果需要修改，就创建新的服务器替换现有的服务器。实践这一理念至少需要两个前置条件：

* 应用程序无状态：不可变服务器本地不可存储状态数据，如会话、缓存、日志等，都需要存储在外部服务中。这么做的理由显而易见：如果这些数据存储在服务器内部，那么对服务器进行替换的时候，这些数据就会丢失。
* 使用模板部署：使用模板可以快速的批量部署服务器，同时使用模板库对模板进行“版本管理”，这样对线上环境的每次变更都会被记录在案。使用容器模板部署是首选方案，例如可以使用Jenkins将代码和运行环境编译为Docker镜像并部署。使用虚拟机模板也可以达到类似的目的，但是虚拟机模板体积过大，存储和传输虚拟机模板都会带来极大的开销，同时虚拟机模板还缺少单一的模板制作和管理工具，实施过程中还可能会遇到Hypervisor适配、驱动更新等琐碎问题，这些问题累积起来导致使用虚拟机模板部署举步维艰。另外，使用Puppet、Chef等配置管理工具也可以实现服务器的快速部署，但是编写和测试配置管理脚本会带来很大的额外工作量。

不可变服务器带来的好处是：

* 易于跟踪线上变化：由于运行在线上的服务器都由模板创建，而且创建之后就不会再被修改，所以线上的运行的每个服务器都可以在模板库里找到“真身”，并且使用同一个模板创建的所有服务器都是一模一样的。如果允许直接修改线上服务器，那么随着时间的推移，这些服务器将会进入某种不可预知的状态，即，谁也说不清楚这些服务器上到底被修改了些什么，这种情况一般被称为配置“漂移”或者“蚀变”；此时同一用途的一组服务器，例如一个业务集群，也必然会陷入不一致的状态，而不一致的集群会给运维带来很多麻烦，例如难以对其进行批量操作，因为同一个操作在不同的服务器上可能会产生不一致的后果，同时也很难保证部署在这样的集群上的应用的每个节点会有一致的表现，在集群规模很大的时候这简直就是一场灾难。很多公司会通过文档和管理流程记录线上服务器的每一次修改，或者采购变更管理软件对线上服务器的修改做统一管理，但是有什么能比根本不去修改来的更加简单呢？
* 易于恢复故障：如果线上服务器发生故障，那么可以使用对应的模板迅速完成重新部署；如果是模板本身的问题，那么可以通过部署前一个运行正常的模板替换问题服务器，快速完成回退。如果直接对线上服务器进行修改，一旦引发故障，很有可能无法实现回退，因为根本不知道服务器之前的状态是什么！

### 理念六：提供声明式接口

这里的声明式来自编程泛型概念中的声明式编程（Declarative Programming，有时候也被翻译成申明式或者宣告式）。声明式编程的意思是告诉计算机完成任务的目标，然后让计算机自行选择执行路径到达目标。与其相对应的是命令式编程（Imperative Programming，有时候也被翻译成指令式），意思是告诉计算机完成任务的各个步骤，然后计算机按照既定步骤执行。例如：

```
function double (arr) {
  return arr.map((item) => item * 2)
}
```

和

```
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}
```

这两个完成同样任务的代码片段可以为两种编程模式做基本的示意：前者是声明式，后者是命令式，显然前者更加简洁并且一目了然。面对命令式的代码，大脑需要像解释器那样将代码按步骤读入、并考虑代码与其所在上下文的关系，才能明白这段代码想要做什么，这种方式更加接近于机器操作，而不是人类心理。而声明式的代码直接描述任务目标，不落入执行步骤的细节，也不依赖于代码所在的上下文。这样看起来声明式编程似乎比命令式编程更加优越，但是实际上开发人员很少编写声明式的代码，究其原因，一方面是因为开发人员喜欢控制事情的发展，习惯于描述过程，另一方面是因为对任务目标做抽象而完备的提炼并将其正交分解在很多情况下都是件令人望而生畏的工作（思考了很长时间却只写了几行代码，领导会不高兴）。所以，虽然两种编程模式几乎诞生于同一年代，但是在随后的几十年中，占据主流的始终是命令式编程。直到近十年，随着多核处理器和并行计算的兴起，由于声明式编程可以大大降低并行程序的编写难度，该模式才开始得到了业界的高度关注（最著名的例子就是MapReduce）。

声明式聚焦于对任务目标的描述，这里的任务可大可小，如果是类似上述代码片段中的那种小任务，那么声明式就纯粹是一种编程模式，如果是使用者视角的任务，即软件最终功能的呈现，那么声明式则上升为一种设计理念。如果软件可以提供声明式接口，例如，枚举软件功能域的所有任务目标，并设计一种用于描述任务目标的领域专用语言，让使用者只需描述任务目标即可完成任务，而无需纠缠于具体的执行过程，那么软件的易用性可以得到极大的增强。例如，SQL就是数据库的声明式接口：用户使用SQL描述想要获取什么样的数据，即声明任务目标，数据库便会自行选择获取这些数据的最佳执行路径，并将数据返回给用户。众所周知，使用SQL获取数据，要比使用命令式语言自行编写处理过程去获取数据容易的多：数据库可以帮助用户收集数据的统计信息、维护索引、选择最佳执行计划、并将任务分配到多个CPU甚至多台服务器，这些工作如果由用户自行完成，代码量会有成千上万行。

声明式思想在微服务模式的实践中也显得尤为重要，试想在部署微服务的时候，如果运行平台没有提供声明式的操作方式，那么必然会遇到如下问题：

* 需要专人编写部署脚本实现部署过程中的每一步操作。
* 部署微服务的目标环境往往是动态的，即脚本执行的上下文是变化的，依赖上下文的命令式脚本很难保证部署结果的一致性和稳定性。
* 需要在部署脚本中处理各种异常情况和边界条件，高度依赖编写者的技术能力和缜密思维。
* 部署过程很难具备事务性，如果脚本在执行过程中被异常情况中断，往往会产生意想不到的中间状态。
* 如果需要多人维护同一个脚本，协作会非常困难。
* 需要另行编写文档描述部署流程，需要通过管理流程保证文档和脚本的一致性。

如果微服务运行平台可以提供声明式接口，即用户编写部署任务目标的描述文件，运行平台解析这个文件并自动选择到达目标的执行路径，事情则会简单的多：

* 用户无需考虑部署流程和目标环境中的细节。
* 多次部署和在不同的目标环境中部署都会得到一致的部署结果。
* 描述文件易于理解，易于多人维护。 
* 描述文件即部署文档，描述文件的版本化即部署结果的版本化。
* 天然具备事务性，要么部署成功，要么什么都不做。

实际上这个转变过程和声明式编程在并行计算中的兴起非常类似，分布式系统中很多深受技术人员喜爱的开源产品，例如容器化应用管理系统Kubernetes、配置管理工具Ansible和NixOS等Linux发行版，都是声明式思想的贯彻者。Kubernetes的设计原则中，声明式思想被列为首位。

## 原则

本章的开头提到，理念在经过结合实际情况的细化和量化，以作为实际工作的指导方针之后，就变成了原则。前文列举的六个理念，可以就此改造成原则，除此之外，我们再来介绍两组和微服务高度相关的知名原则。

### 12-Factors

12-Factors经常被直译为12要素，也被称为12原则，12原则由公有云PaaS的先驱Heroku于2012年提出（原文参见12factor.net），目的是告诉开发者如何利用云平台提供的便利来开发更具可靠性和扩展性、更加易于维护的云原生应用。距离12原则的提出已有五年之久，12原则的有些细节可能已经不那么跟得上时代，也有人批评12原则的提出从一开始就有过于依赖Heroku自身特性的倾向，不过不管怎么说，12原则依旧是业界最为系统的云原生应用开发指南，我们可以把它作为一个非常有力的参考，但是也千万不要教条。

#### 原则1：一份基准代码，多份部署

这个原则不管对微服务模式还是其他软件开发模式来说都非常基本，所以被列为12原则的第一条，该原则包括如下四个子原则：

1. 使用代码库管理代码，一般是Git或者SVN，这个要求非常初级，相信本书的读者都会遵守。
1. 一份基准代码（即一个代码库）对应一个应用。如果通过一份基准代码可以编译出多个应用，那么应该考虑将该基准代码按应用拆分为多份；如果一个应用需要多份基准代码，那么要么考虑将多份基准代码合并，要么考虑将该应用按基准代码拆分为多个。
1. 不允许多个应用共享一份基准代码，如果确实需要共享，那就把需要共享的基准代码的稳定版本发布为类库，然后通过依赖管理策略进行加载。
1. 同一应用的多份部署可以使用同一份基准代码的不同版本，但是不可以使用不同的基准代码，类似原则2，使用不同基准代码的应用不应被视为同一应用。

违反子原则2和3，会给代码管理和编译工作带来麻烦：

1. 如果一份基准代码可以编译出多个应用，那么这几个应用之间必然会存在不清晰的依赖关系，随着时间的推移，这种依赖关系会变得愈加混乱，以至于修改一个应用的代码，会给其他应用带来不可预知的影响。这样的基准代码显然极难维护。
1. 基准代码的划分和应用的划分非常类似，也是系统边界的一种体现，如果一个应用需要从多份基准代码编译，那么多数情况下这个应用的内外部边界问题会存在问题。如果边界不存在问题，那么请将多份基准代码合并为一份，而不是维持这种古怪的设计。
1. 如果多个应用不是通过类库，而是直接共享一份基准代码，那么这份被共享的基准代码会很难维护，对这份基准代码的修改必须谨慎考虑对多个应用可能造成的影响。正确的方式是将这份基准代码发布为类库，保持清晰的边界和接口约定供其它应用调用。

#### 原则2：显式声明依赖关系

这里的依赖指所有的依赖，包括应用程序本身的类库和操作系统层面被应用程序所使用的库文件或者其他二进制文件，都必须进行显示声明，并对版本做出明确的指定。不要假定运行环境中已经存在应用所需要的任何依赖项，而是应该假定什么都没有（即使有也很可能不是应用所需要的版本）。如果使用容器方式进行部署，容器的基础镜像很可能是Busybox或者Alpine之类的迷你Linux，那么就几乎等于什么都没有。如果使用微服务模式，理想情况下，微服务之间的依赖关系也应该进行显示声明。

以前我们往往不会对依赖做如此严格的管理，因为应用不会有太大规模的部署，也不会进行频繁的发布，如果发现运行环境里缺少某些依赖，那么就临时手工处理一下，也不是什么太大的问题。如今在微服务模式下，应用的部署规模大、发布频率高，还记得前文所说的“不可变服务器”吗？如果这个时候还是使用原有的模式，则会带来混乱。

声明依赖的方式有很多，常见的方式是使用依赖清单，根据依赖清单进行依赖检查，同时使用依赖隔离工具保证应用不会调用系统中存在但是依赖清单中未声明的依赖项；另一种方式是使用容器技术，将应用和依赖打包为容器镜像，依赖的声明和隔离就一并解决了。

#### 原则3：在环境中存储配置

首先需要明确的是，这里的配置指与部署环境有关的配置，例如：

* 数据库、消息代理、缓存系统等后端服务的连接配置和位置信息，如URL、用户名、密码等。
* 第三方服务的证书。
* 每份部署独有的配置，例如：域名、连接数、与部署目标环境资源规模有关的JVM参数等。

所有部署中都相同的信息，例如原则2里讲到的依赖信息，不在本原则所讨论的范围内。一些虽然在不同的部署中有所差异、但是和业务相关的信息，例如资金结算的转换比例，也不属于本原则所讨论的配置。

我想大多数的开发者都知道如何通过使用配置文件实现配置和代码的分离，但是这种方式仍然存在一些缺点，例如：

1. 配置文件容易被开发人员不小心提交到代码库中，造成密码、证书等敏感信息泄露。提交到代码库中的配置文件还容易被和应用一起部署到目标环境中，很可能会导致在目标环境中应用了错误的配置或者造成配置冲突。
1. 配置文件会分散在不同的目录中，并且有不同的格式（配置文件的格式往往与开发语言和框架相关），这会给配置的统一管理造成困难。

为了避免上述问题，本原则要求将在环境中存储配置。一种典型的方式是把配置存储在环境变量中，这会使配置和代码彻底的分离，格式上也与开发语言和框架再无瓜葛，并且也不会被误提交到代码库中。还可以使用Spring Cloud Config Server这类配置管理服务进行配置推送，并将配置的历史版本和变更原因也一起管理起来。

#### 原则4：把后端服务当作附加资源

这里的后端服务指的是应用运行所依赖的各种服务，例如数据库、消息代理、缓存系统等，对于云原生应用来说，往往还会有日志收集服务、对象存储服务、以及各种通过API访问的服务；当作附加资源指的是把这些服务作为外部的、通过网络调用的资源。

该原则有如下几层含义：

1. 不要将这些服务放在应用本地：云原生应用要求应用本身无状态化，那么状态信息就应该存储在外部服务中（参见不可变服务器）。同时，微服务模式要求应用责权单一以实现可靠性和扩展性，如果在应用本地放置数据库，那么微服务平台将无法通过更换应用的故障实例实现应用的高可用性，也无法通过自动化的横向伸缩实现扩展性，因为应用实例内包含两种性质完全不同的软件（应用和数据库），无法对两者使用同一种方式进行横向扩展。另外，如果将这些服务放在应用本地，那么也无法通过充分利用云平台提供的能力简化运维工作，例如，如果在应用本地放置数据库，而不是使用云平台提供的数据库服务，那么显然无法利用数据库服务提供的自动备份、安全、和高可用等特性。
1. 通过URL或者服务注册/认证中心访问这些后端服务：应用应该能够在不进行任何代码修改的情况下，在不同的目标环境中进行部署，应用不应该和后端服务的任何一种具体实现存在紧耦合关系。
1. 类似“显式声明依赖关系”原则，应用最好也能够对其使用的这些后端服务进行显示声明，以方便云平台对服务资源进行自动绑定，在后端服务出现故障的时候，云平台也能够对其进行自动恢复。

#### 原则5：严格分离构建、发布和运行

在本原则中，构建、发布和运行这三个概念可能和从前有所不同，因此有必要首先对其进行明确：

* 构建指的是将应用代码转化为执行体的过程：构建时会拉取特定版本的代码和依赖项，将其编译为二进制文件（针对编译型语言），并和资源文件一起打包。
* 发布指的是将构建的结果和部署所需的配置相结合，并将其放置于运行环境之中。
* 运行指的是将发布的结果启动为运行环境中的一个或多个进程。

本原则要求构建、发布和运行这三个步骤严格区分：

1. 禁止直接修改运行状态的代码或者对应用进行打补丁，因为这些修改很难再同步回构建步骤，这时运行状态的代码就成为了“孤本”。同时，也不应该在运行期间修改应用的配置，配置的修改应该仅限于发布阶段（参见不可变服务器）。
1. 运行这一步骤应该非常简单，仅限于启动进程，资源文件的关联应仅限于构建阶段，配置的结合应仅限于发布阶段。

同时，每一次发布都应该对应一个唯一的发布ID，发布的版本应当像一个只能追加的账本，一旦发布就不能修改。这么做的好处是：

1. 每一份运行状态的代码都可以在对应的发布和构建阶段找到它的来源，这是实现重新发布、故障实例的自动替换、发布出错后的版本回退等机制的基础。
1. 运行步骤非常简单，这样在硬件重启、实例故障和横向扩展等情况下，应用可以简单和快速的实现重启。

#### 原则6：以一个或多个无状态的进程运行应用

本原则要求应用进程的内部不要保存状态信息，任何状态信息都应该被保存在数据库、缓存系统等外部服务中。应用实例之间的数据共享也要通过数据库和缓存系统等外部服务进行，直接的数据共享不但违反无状态原则，还引入了串行化的单点，这会为应用的横向扩展带来障碍。在微服务模式下，应用不应该在自身进程内部缓存数据以供将来的请求使用，因为微服务模式以多实例方式运行应用，将来的请求多半会被路由到其他实例，此时虽然可以使用粘滞会话将请求保持在同一个实例上，但是无论是云原生应用还是微服务模式都极力反对使用粘滞会话，原因如下：

1. 很难对粘滞会话实现负载均衡，因为粘滞会话的均衡性不仅决定于负载均衡策略，还和会话本身的行为相关，例如，可能存在应用某些实例上的会话已经大量退出，而另一些实例上的会话依然处于活动状态，此时这两部分实例的负载处于不均衡状态，而负载均衡器无法将活动会话转移到空闲的应用实例。
1. 启动新的应用实例不会立即提高应用的整体处理能力，因为这些新实例只能承接新会话，旧的会话依旧粘滞在旧的应用实例上。
1. 应用实例退出会导致会话丢失，所以在实例发生故障时，即使云平台可以对故障实例进行自动替换，也会导致用户数据丢失。即使是对应用实例进行人工维护，也需要在维护之前对该实例上的会话进行转移，这往往意味着需要编写复杂的业务代码。在传统模式下，可以通过在双机之间进行会话复制来实现对用户无感知的单机下线维护（虽然会付出处理能力减半的代价），但是在微服务模式下，应用的实例数量往往远不止两个，在大量的实例之间进行会话复制会使实例之间原本非常简单的逻辑关系复杂化，此时将无法通过云平台对其进行无差别的自动化维护。另外，在实例之间进行会话复制也意味着实例之间存在着直接的数据共享，这会为应用的横向扩展带来障碍。

所以，粘滞会话是应用实现可用性和扩展性的重要障碍，使用粘滞会话显然是种得不偿失的选择。更好的实现方式是将会话信息存储在缓存服务中。

#### 原则7：通过端口绑定提供服务

服务端应用通过网络端口提供服务，这点毋庸置疑，但是本原则还有如下两个深层次的含义：

1. 无论是云原生应用还是微服务模式都要求应用应该完全自我包含，而不是依赖于外部的应用服务器，端口绑定指的是应用直接与端口绑定，而不是通过应用服务器进行端口绑定。如果一定要使用应用服务器，那就使用嵌入式应用服务器，无论是云原生应用还是微服务模式都极力反对将多个应用放置于同一个应用服务器上运行，因为在这种模式下，一个应用出错会对同一个应用服务器上的其他应用造成影响，也无法针对单一应用做横向扩展。
1. 端口绑定工作应该由云平台自动进行，云平台在实现应用到端口的绑定之外，还需要实现内部端口到外部端口的映射和外部端口到域名的映射。在应用的整个生命周期内，应用实例会经历多次的重新部署、重启或者横向扩展，端口会发生变化，但URL会保持不变。

#### 原则8：通过进程模型进行扩展

与通过进程模型进行扩展相反的方式是通过线程模型进行扩展，这是一种相对较为传统的方式，典型的例子是Java应用。当我们启动一个Java进程的时候，通常会通过JVM参数为其设置各个内存区域的容量上下限，同时还可能会在应用层面为其设置一个或者多个线程池的容量上下限，当外部负载变化时，进程所占用的内存容量和进程内部的线程数量可以在这些预先设置好的上下限之间进行扩展，这种方式也被称为纵向扩展或者垂直扩展。但是这种方式存在一些问题，首先，在进程的内存容量和线程数量提高时，应用的某些性能指标可能不会得到同步提高，甚至可能会下降（这往往是因为程序对某些无法扩展的资源进行争用所造成的），这种参差不齐的性能扩展对外部负载提高的承接能力会很不理想，有时甚至会适得其反；其次，为了使进程本身可以完成纵向扩展，还需要在虚拟机层面或者容器层面为其预留内存资源和对应的CPU资源，这会造成大量的资源浪费（当然，也可以使虚拟机或者容器跟随进程一起进行纵向扩展，这在技术上是可行的，但是会为虚拟机或者容器管理平台的资源调度造成一些不必要的困难，例如频繁的虚拟机迁移或者容器重启）。

所以，现在更为推崇使用“固定的”进程（对前面Java应用的例子来说，就是固定的内存容量和线程池容量），在外部负载提高时，启动更多的进程，在外部负载降低时，停止一部分进程，这种方式就是本原则所说的通过进程模型进行扩展，有时候也被称为横向扩展或者水平扩展。这种扩展方式的好处是，在进程数量增加的时候，应用的各种性能指标会得到同步的提高，这种提高即使不是线性的，也会按照一种平滑和可预期的曲线展开，可以更为稳定的应对外部负载的变化。

云原生应用和微服务模式极力推崇将通过进程模型进行扩展作为唯一的扩展方式，除了前文所述，还有一个原因是进程是云平台可以操作的最小运行单元（当然，可以通过其他技术手段去操作线程，但是那不会成为云平台的通用技术特性），云平台可以根据各个层面的监控数据，通过预设规则决定是否为应用增加或者减少进程，例如，当前端的负载均衡器检测到访问某个后端应用的并发用户数超过某个阈值时，可以立即为这个后端应用启动更多的进程，以承接更大的负载，同时还可以选择是否对该应用后端的数据库进行扩展。如果此时选择对应用进行纵向扩展，则云平台既不知道应用处理能力的变化，也无法对这种变化进行预期管理，更无法使应用的前后端对这种变化进行联动，即该应用的扩展行为脱离了云平台的管理。在微服务模式下，如果大量的进程都采用纵向扩展方式，则会为平台的资源调度带来极大的混乱。

_注3：该原则似乎更适合被称为横向扩展原则，但是为了和12原则的原文保持一致，这里我们仍然将其称为“通过进程模型进行扩展”。_

#### 原则9：快速启动和优雅终止可最大化健壮性

该原则要求应用可以瞬间（理想情况下是数秒或者更短）启动和停止，因为这将有利于应用快速进行横向扩展和变更或者故障后的重新部署，而这两者都是程序健壮性的体现。前文不止一次提到过应用的快速启动，在理念章节的开头，我们提到过平价的进程生成对多道程序设计至关重要，而微服务模式在某种程度上可以认为是多道程序设计在Web领域和分布式系统下的进一步扩展，这里所说的平价进程生成指的是操作系统的一种特性，是应用快速启动的基础，除此之外为了保证应用可以在数秒内完成启动，还需要大量的优化工作，需要开发人员掌握复杂的调优技术与工具，有些工作必须在应用的初始设计阶段完成，例如：如果应用体积过大或者是引用了太多的库文件，那么再多的后期优化也无法将启动时间降低到数秒以内。在“原则5：严格分离构建、发布和运行”中我们还提到，应用的运行步骤应该非常简单，这里的“简单”也隐含着快速的意思，目的是为了在硬件重启、实例故障和横向扩展等情况下，应用可以快速的实现重启。除此之外，“原则6：以一个或多个无状态的进程运行应用”也与应用的快速启动有关，遵守无状态原则，使用云平台提供的缓存服务，而不是在应用内部加载缓存，可以避免在应用启动期间进行耗时的缓存预热。

比起应用的快速启动，优雅终止（Graceful Shutdown）需要考虑的问题会更为广泛一些。优雅终止需要尽可能降低应用终止对用户造成的不良影响（对于微服务应用，用户可能是人，也可能是其他微服务），对于短任务来说，这一般意味着拒绝所有新的请求，并将已经接收的请求处理完毕后再终止；对于长任务来说，这一般意味着应用重启后的客户端重连和为任务设置断点并在重启后继续执行。除此之外，优雅终止还需要释放所有被进程锁定的资源，并对事务的完整性和操作的幂等性做出完备的考虑。

最后，应用还必须应对突如其来的退出，在硬件出现故障时或者进程崩溃时，应用需要保证不会对其使用的数据造成损坏，遵守无状态原则、将数据交由后端服务处理的应用可以很容易的将应对突然退出的复杂度外部化。

#### 原则10：开发环境与线上环境等价

本原则的浅层次含义是要求在开发环境和线上环境中使用相同的软件栈，并尽可能为这些软件栈使用相同的配置，以避免“It works on my machine.”这类问题。本原则反对在不同的环境中使用不同的后端服务，虽然可以使用适配器或者在代码中做出兼容性考虑以消除后端服务的差异，但是这将牵扯开发人员和测试人员大量的精力以保证这些适配器和代码确实可以按预期工作，在应用的整个开发周期中，这将积累极大的额外工作量，是一种非常不必要的资源浪费。

近年来个人电脑的性能大幅提高，开发人员一度得以在本地开发环境中运行与生产环境中一致的软件栈，而不是像曾经那样采用轻量的替代方案。但是随着云原生应用和微服务模式的流行，情况又发生了微妙的变化：开发微服务时需要依赖云平台提供的基础服务和其他微服务，越来越难以把这些服务完整的运行在本地，与此同时，完全的在线开发愈发成为一种趋势，那样的话至少在软件栈上开发环境和线上环境就真的没有任何区别了。在我编写这段文字的时候，Red Hat公司刚好在洽购在线开发环境创业公司Codenvy用以充实他们的云平台产品OpenShift，而另一家与Codenvy类似的创业公司Cloud9在差不多一年前被Amazon公司收购。

本原则的深层次含义是尽量缩小开发环境和线上环境中时间和人员的差异。开发环境中的代码每天都在更新，而这些更新往往会累积数周甚至数月才会被发布到线上环境，这是开发环境和线上环境在时间上的巨大差异；开发人员只关心开发环境，运维人员只关心线上环境，开发人员和运维人员在工作上鲜有交集，这是开发环境和线上环境在人员上的巨大差异。对于前一个差异，本原则要求更为密集和频繁的向线上环境发布更新，要求建立机制以保障开发人员可以在数小时甚至数分钟内既可将更新发布到线上，这也正是本章理念部分中持续交付所提倡的；对于后一个差异，本原则要求开发人员不能只关心开发环境中自己的代码，更要密切关注代码的部署过程和代码在线上的运行情况，这也正是DevOps所提倡的。

#### 原则11：把日志当作事件流

应用程序应该将其产生的事件以每个事件一行的格式按时间顺序输出，这点毋庸置疑，但是本原则想说的其实是：应用程序不要自行管理日志文件。

以前我们习惯将应用程序产生的事件分门别类的输出到不同的日志文件，并为每个日志文件指定在本地文件系统上的存储位置，为了避免单一日志文件过大，还会为它们配置轮转策略。该原则极力反对上述做法，而是要求应用程序将日志以事件流的方式输出到标准输出STDOUT和标准错误输出STDERR，然后由运行环境捕获这些事件流，并转发到专门的日志处理服务进行处理。这样做的原因是：

1. “原则6：以一个或多个无状态的进程运行应用”要求应用程序无状态，那么应用程序就不应该将日志文件这种价值信息存储在本地文件系统上。当然，可以在本地运行一个日志收集进程读取日志文件，并将其转发到专门的日志处理服务，以保证价值信息不被意外丢弃，但是这将带来如下问题：
    * 需要提供一种机制以保证日志收集进程可靠运行。
    * 需要通过配置文件告知日志收集进程去哪里读取日志文件。
    * 需要在应用程序所在的虚拟机或者容器上为日志收集进程开放一个网络端口以供其发送日志内容，这不仅增加了网络的复杂度，还给网络安全带来了隐患。
    
    由此可见，直接将日志输出到STDOUT和STDERR并由运行环境对其进行捕获远比这种方案来的简洁和可靠。
1. 在存在专门的日志处理服务时，由应用程序自行对日志进行分类显得死板和毫无必要；只需将日志以事件流方式发送给日志处理服务，日志处理服务可以对这些日志按不同视角进行灵活的分类，而不是受限于一种既定的分类规则。
1. “原则6：以一个或多个无状态的进程运行应用”中还提到“微服务模式以多实例方式运行应用，将来的请求多半会被路由到其他实例”，所以单个应用实例的日志无法描述完整的业务操作，不具备业务层面的价值。必须将应用所有实例的日志汇总到日志处理服务，由日志处理服务按特定规则（如按用户ID或者对象ID）对其进行聚合，才能完整展现应用在业务层面的操作过程。应用在以多实例方式运行时，应用的单个实例可能会因为软硬件故障而重启，或者被横向扩展机制创建和销毁，所以必须将应用所有实例的日志汇总，才能完整的描述应用的运行情况。

#### 原则12：后台管理任务当作一次性进程运行

这是12原则的最后一条，也是最晦涩的一条。如果你在看过原文之后觉得哪里有些不大对，不必担心，因为很多人的想法和你一样。在本节的开头曾提到有人批评12原有过于依赖Heroku自身特性的倾向，这些批评多半可能是本原则导致的。事实上，通过SSH接入线上环境并使用脚本语言执行管理任务的做法已经不再被提倡，无论是云原生应用还是微服务模式都极力反对这种做法，原因可以参见“理念五：不可变服务器”和“理念六：提供声明式接口”。另外还有一个原因显而易见：你的应用有数个或者数十个实例，那么应该登录到哪个实例中执行管理任务呢？如果在管理任务执行的过程中，所在实例因为软硬件故障重启，或者被横向扩展机制销毁，那又该怎么办？

正确的做法是，如果管理任务是修改应用配置，那么应该通过配置管理服务进行操作，参见“原则3：在环境中存储配置”；如果管理任务是批处理任务，例如数据的迁移、清洗或者检查，那么应该通过云平台的批处理机制进行操作，大多数的云平台都会提供这种机制，例如Kubernetes的Jobs。本原则还提到“应用的管理进程应该和应用的常驻进程运行于同一环境，并使用相同的代码、版本和配置”，这是一条比较有价值的建议，可以避免由于环境或代码等不一致造成的一些潜藏问题。虽然现在不提倡通过SSH接入应用常驻进程所在的环境并执行管理任务，但是如果你使用容器技术，那么很容易通过容器模板创建一个和应用常驻进程一致的运行环境，并在其中执行管理任务。

### AKF扩展立方



## 定律

### 定律一：侯世达定律

道格拉斯·理查·郝夫斯台特（Douglas Richard Hofstadter），美国印第安纳大学文理学院认知科学教授，主要研究领域包括意识、类比、艺术创造、文学翻译以及数学和物理学探索，侯世达是他的中文名。这位看起来和软件行业关系不大的学者（他本人也说“对计算机没有兴趣”），其普利策奖著作《哥德尔、埃舍尔、巴赫》中的一句格言却在软件行业广为流传，这句格言被称为侯世达定律（Hofstadter's Law）：

>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。

侯世达定律指出完成复杂任务需要花费的时间总是很难预计。这个定律经常被软件开发人员提起，特别是在进行项目计划的讨论时。定律使用自指方式（或者说是递归）表述了即使充分意识到了任务的复杂性，仍然难以准确预计完成任务所需时间的窘境。

即使使用微服务模式开发你的应用，侯世达定律依然有效，因为在评估开发所需时间的时候，你已经将微服务模式带来的效率提高考虑在内了，不是吗？

### 定律二：90-90定律

90-90定律（Ninety-ninety Rule）是软件行业又一个有名的定律，源自贝尔实验室专家汤姆·卡吉尔（Tom Cargill）的一句玩笑话：

>前90%的代码要花费90%的开发时间，剩余的10%的代码要再花费90%的开发时间。

合计180%的时间总量用看似荒诞的方式指出了软件项目的一个顽疾——项目完成时间常常大幅超出预期。这个定律体现了在评估软件项目完成时间的时候，对简单任务和困难任务的时间分配太过粗糙的问题，也揭示了很多项目被迫延期的原因：最后10%的工作的难度，是前90%工作的难度的9倍（如果不是10倍或以上的话）。

### 定律三：布鲁克斯定律

是的，这个布鲁克斯就是IBM System/360系统之父和软件工程著作《人月神华》的作者弗雷德·布鲁克斯（Fred Brooks）。布鲁克斯定律（Brook's Law）的内容是：

>给一个延期的项目增加人手会使它拖得更久。

弗雷德·布鲁克斯在《人月神话》中提出了这一定律，并对其成立的原因做出了如下解释：

1. 新加入项目的人员需要学习一段时间才会有产出，教会他们反而会占用团队中老成员的时间。
1. 人员数量增加，沟通成本也会增加，最糟糕的情况下是指数级增加。
1. 任务的有限可分性：一些任务不可分割，增加人手不能使任务完成的更快。

那项目延期了怎么办？弗雷德·布鲁克斯给出的办法是：降低项目目标。

### 定律四：埃托雷观察

埃托雷观察（Ettorre's Observation）的内容是：

>另外一条路看起来会走得更快。

软件项目中存在大量的路径选择问题，大到选择一个技术方向，小到选择一个具体问题的解决方案，当我们在已选的路径上遇到困难时，经常会觉得之前如果选择另一条路径，事情会更加顺利。这种想法经常会导致个人的犹豫不决和团队成员之间的不信任，最终影响项目的整体进度。然而另一条路径很可能只是看起来更加顺利而已，因为你在实践当前路径，对当前路径中会碰到的问题有着更多的了解，而另一条路径仅存于你的想象之中，你“幻想”它好的一面，却不了解它坏的一面。如果你真的切换到另一条路径，八成你又会觉得之前那条路径会更加顺利，这就是“埃托雷观察”，永远的“另外一条路看起来会走得更快”。

所以，在软件项目中，做路径选择的时候要充分验证，一旦确定路径，就不要因为遇到的困难而犹豫不决。

### 定律五：康威定律

这是出现在半个世纪之前的古老定律，随着微服务模式的流行，该定律重获新生，并前所未有的走入公众视野，网上到处充斥着有关康威定律的文章，想必本书的读者也读到过一些。该定律对微服务模式来说如此重要，以至于本书也不能免俗和避而不谈。

上个世纪六十年代，著名计算机科学家梅尔文·康威（Melvin Conway）在其职业生涯中观察到了一个有趣的现象：软件产品的架构在很大程度上会反映其开发团队的组织结构。后来康威将其推广为一种社会学观察，并为其撰写了一篇名为“How Do Committees Invent?”的论文，其思想一般被概括为：

>任何设计系统的组织，必然会产生以下设计结果：该系统的结构就是该组织沟通结构的写照。

当时梅尔文·康威非常谦逊的仅仅将这种现象称作是自己的发现和总结，在将近十年之后，弗雷德·布鲁克斯（就是定律三里的那个布鲁克斯）在其软件工程著作《人月神华》中才将其奉为“康威定律”，随后又在多部软件方面的著作中被反复提及。开源运动倡导者埃里克·雷蒙在其著作《新黑客辞典》中提到“软件的组织和软件团队的组织将是一致的”，并特别使用Congruent（意思是全等，就是全等三角形的那个全等）这个单词形象的描述这种一致性。尼尔·哈里森和詹姆斯·科普林在其著作《敏捷软件开发的组织模式》中提到，如果组织的构成（例如团队或部门）不能密切的反映产品的基本部件，或者组织之间的关系不能反映产品部件之间的关系，那么项目将遇到麻烦。简单的说：产品结构是其组织沟通结构的缩影。实际上这里的系统或产品，指的是广义上的系统和产品，并不仅仅是软件，其实梅尔文·康威最初是将文章投稿到《哈佛商业评论》的，可惜商界人士并未立即意识到文章的价值，伟大的发现在相当长的时间内仅在程序员圈子内流传。直到半个世纪之后，投资大师彼得·蒂尔（Peter Thiel）在其著作《从0到1》中，在谈及不入流的产品设计时还曾提到网络电视遥控器的例子：遥控器的点播键又大又醒目，而静音键又小又难找，只是因为点播业务是该企业的主要收入来源，而没人能从静音上赚到钱。这和康威定律所描述的现象十分相似。

在传统的软件开发模式下，组织通常会被按技术职能划分为前后端团队、DBA团队和运维团队，根据康威定律所述，这种组织结构显然不适合微服务模式的软件开发。想必本书的读者都已经十分清楚，在微服务模式下，必须按业务功能去划分团队。各位读者也一定听说过杰夫·贝索斯倡导的“Two-pizza Team”，但是问题的核心并不是团队规模的大小，而是“沟通”。在一次非正式会议上，亚马逊的高层提到团队之间应该进行更多的沟通，贝索斯立刻起身发对：“不，沟通很可怕！”贝索斯所倡导的是，在缩小团队规模的同时，还必须尽可能的减少团队之间的沟通，尽可能的将沟通限制在小规模团队的内部。实际上康威定律所强调的也是组织沟通结构对系统结构的影响。在使用微服务模式进行软件开发时，如果不能有效的减少团队之间的沟通，即使采用了小规模团队，也极有可能导致各微服务之间过高的耦合性。一个微服务应用如果在各微服务之间存在过高的耦合性，那就等于在引入了微服务模式的复杂度的同时，又保留了单体应用的主要缺陷，这是一种非常糟糕的实践。

协程的发明者
