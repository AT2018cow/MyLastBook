# 理念、原则、定律与微服务设计

当我们谈及理念的时候，一般指期望按照某个理想的方式做事，而执行过程中，则有可能因为各种客观因素的限制，导致这种期望无法达成；而原则则不同：原则是必须达成的理念，在执行过程中，需要设立规章制度、流程、工具链等措施，确保原则可以达成。在实际工作中，明确理念和原则的区别至关重要：达成理念，会带来好的结果，应该奖励，不能达成，也不是什么太大的问题，下次再努力即可；遵守原则，是分内之事，违反原则，会带来坏的结果，应该惩罚。当然，结果的好坏，是个相对的概念，与投入的时间、资本、人员等诸多因素有关，某种意义上，一个组织的进步，就是把优秀的理念逐渐变成原则的过程。

在实际工作中，理念可以是感性的和鼓舞人心的，而原则则必须是：

* 措辞明确的：必须明确阐述该怎样做和达到什么样的目标，以作为实际工作的指导方针；
* 现实可达的：必须是在付出一定努力之后可以实现的，制定难以实现的原则，除了不具备指导实践的意义之外，还可能会打击团队士气；
* 可度量的：必须是量化的，实际工作中，不能只说“接口简洁”，还要将简洁的程度加以量化，例如，“接口数量小于m个”、“参数数量小于n个”、等等；
* 可检验的：实际工作中，如果提出原则，那么必须对原则的达成情况进行检验，不能检验达成情况的原则只是空谈；

与原则相关的另一个概念是定律（也称法则），人们经常混淆这两个概念，尤其是在翻译文章中。实际上，原则和定律是两个完全相反的概念，原则是“经过一定努力可以达到的”，定律是“经过再多努力也难以违背的”。定律一般会陈述一种难以违背的现象，也可能是一个假言命题：如果你的状况不幸落入假言命题的前件，那么绝大多情况下，你将面对该假言命题的后件所描述的糟糕结局。

下文我们会介绍一些与微服务开发密切相关的理念、原则和定律。

## 理念

早期的操作系统进程生成代价昂贵，缺乏灵活易用的进程控制机制。例如上个世纪七、八十年代广为流行的VAX VMS系统，启动进程开销极大、速度缓慢并且需要特别的权限，同时，这类操作系统缺乏灵活的进程间通讯机制，难以通过多个进程的协作实现应用功能，这些问题迫使开发者编写怪物般的巨大单体应用，将越来越多的功能和特性塞入单个程序之中，久而久之，怪物般的应用像怪物般失控，或者因不堪重负而内部崩溃。Unix操作系统的出现，带来了低价的进程生成能力和简便的进程间通讯机制，使得编写多个功能单一的小程序，并通过管道和过滤器彼此协作、组成一个均衡系统成为可能。

Unix致力于降低进程生成的开销、提供多种方法简化进程间通讯、并提倡使用能够由管道和套接字传递的简单、透明的文本格式数据，从而鼓励开发者将大型程序分解成多个协作进程，鼓励每个进程“做单件事并做好”的设计风格，从而使大型程序结构简单、功能强大、且稳定可靠。这就是Unix最具特点的模块化程序设计方法，在历史上被称为“多道程序设计”。随着Unix的流行，这种编程方式成为开发复杂应用的默认方式，以至于时不时的出现这样的笑话：

>Unix新手：“我关闭了音乐播放器，为什么音乐还在响？”
>Unix老手：“你关闭的只是播放器的图形界面，并不是播放器的引擎。”
>Unix新手：“……”

发生这样的事情，显然是因为播放器的界面和后端的解码器是两个进程，通过进程间通讯机制彼此协作，共同完成一个完整的音乐播放器功能。这种设计很多好处，例如：

1. 开发者可以开发多个不同风格的界面，并且很容易的将一个界面换成另外一个。
1. 开发者可以调用不同的后端解码器，以支持不同的音频格式，引入新的音频格式，或者换掉现有的解码器，也非常简单。
1. 社区已经有很多成熟的解码器，拿来用即可，使得播放器的开发变得非常简单。
1. 界面与解码器可以使用不同的语言开发，即可以用最适合的语言开发各个独立的程序模块。

当然，一个设计良好的音乐播放器，在图形界面被关闭的时候，是可以发消息通知后端的解码器将自己关闭的（或者也可以使用现代Unix的Init系统配置进程依赖关系，将图形界面和后端程序同时关闭）。但是即使不是这样，在Unix世界生存的人们也对其习以为常，可见这种开发模式的普遍性。即使是到了今天，当你在OS X的终端应用里退出Shell的时候，终端应用的图形界面也不会随之关闭，不是吗？

平价的进程生成和简单的进程控制对多道程序设计至关重要，可惜多年以后，Java语言开始流行，JVM屏蔽了底层操作系统的差异，开发者在大多数时间只要和JVM打交道，即可完成手头的工作，操作系统变得无足轻重，操作系统的优秀机制对软件开发带来的便利性也逐渐淡出开发者的视线。遗憾的是，JVM并没有提供类似Unix的进程管理和通讯能力，使得开发者再次倾向于编写怪物般的巨大单体应用，在Java应用服务器出现之后，这种情况没有得到改观，反而愈演愈烈，将多个应用运行在同一个应用服务器之上，形成了无比巨大的单一Java进程，一个微小的Bug都可能造成进程退出，而代码错综复杂的巨大单体应用，出现这种Bug的概率非常之高。这种巨大单体应用的维护成本高昂，哪怕是对其进行必要的更新也变得非常困难，这种应用就像恐龙一样，摄入的能量无法维持自身庞大的身躯，等待它的结局只能是衰亡。

曾经有段时间，业界寄希望于将类似Unix的进程控制和进程通讯能力引入JVM，但是这种工作的复杂度无异于将JVM变成一个操作系统，随着云计算、PaaS等技术的流行，业界开始试图通过另外一种途径解决问题，即微服务模式。

微服务模式提倡每个微服务专注于单一责任与功能，利用模块化的方式组装出复杂的大型应用，微服务之间默认通过REST API和文本格式的数据流通讯以彼此协作。微服务模式面对的问题和解决问题的方式都像极了Unix世界的传统理念，甚至可以认为微服务模式就是Unix多道程序设计模式在Web领域和分布式系统下的进一步扩展，难怪Unix程序员在看到业界鼓吹微服务时，不屑一顾的耸了耸肩膀：“难道不是一直都这样做的吗？”

所以在讨论微服务的设计理念时，我们有必要先回顾一下Unix多道程序设计所提倡的一些理念。技术人员似乎都不愿意回顾历史，尤其是，软件行业的历史只有短短的几十年，回顾如此短暂的历史，似乎远没有展望充满无限可能的未来更加有趣，所以软件行业重复的犯错，有道是“忘记过去的人注定要重蹈覆辙”。

### 理念一：做单件事并做好

程序应该只做一件事并将其做好（Do One Thing and Do It Well），“只做一件事”指的是程序的功能要单一，如果要实现多个功能，那就编写多个程序，提倡“制作很多把专用的刀，而不是一把瑞士军刀”，“将其做好”指的是日后程序都要围绕这个单一功能进行优化。这个理念的提出者一般被认为是道格拉斯·麦克罗伊（Douglas McIlroy）。这个理念有时候也被称为模块原则，不过正如前文所述，在本章的上下文中，原则应该是措辞明确和可度量的，而什么样的事情算是“单件事”、“事情”的边界如何划分？这都需要在具体场景下才能得到明确的定义，所以我们还是将其列为理念。各位读者可能没有听说过道格拉斯·麦克罗伊，但想必一定听说过软件工业的神级人物、Unix的关键开发者、1983年的图灵奖得主——丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson），而道格拉斯·麦克罗伊正是这两位神级人物的领导。在1965年至1986年间，道格拉斯·麦克罗伊在贝尔实验室的计算机技术研发部门做了二十一年主管，这个部门最著名的事迹就是研发了Unix操作系统，丹尼斯·里奇和肯·汤普森正是这个部门的员工。同时，道格拉斯·麦克罗伊还被认为是Unix管道的发明人和Unix核心理念的奠基人。这个理念的原文是：

>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。

这个理念看起来很简单，可是知易行难，什么样的事情算是“一件事”、什么样的任务算是“新任务”？这和在开发什么样的应用、应用开发到了哪个阶段、应用使用者的数量等诸多因素密切相关。举例来说，开发一个在线视频网站，“登录”显然可以看作是“一件事”，如果使用微服务模式，那么可以把“登录服务”作为一个微服务来开发。随着网站规模的增长、用户数量越来越大，网站开始支持多种设备访问，比如电脑、手机、平板电脑、机顶盒等设备，还有Xbox、PlayStation等游戏机。由于来自每种设备的用户数量都十分巨大，这些设备的登录方式和登录界面又存在着较大的差异，“来自不同设备的登录”变成了此时的“一件事”，“登录服务”这一个微服务被拆分成了“电脑登录”、“手机登录”、“平板电脑登录”等多个微服务，由于几代PlayStation的系统差异较大，支持PlayStation访问的登录服务还可以进一步拆分为“PS2登录服务”、“PS3登录服务”、“PS4登录服务”等……这样做的另一个好处是，来自各种设备的登录用户数量差异巨大，例如来自手机的登录用户数可能是来自PlayStation 3的登录用户数的数十倍、来自PlayStation 2的登录用户数的上百倍，如果把对多种设备登录的支持都放在一个微服务里，那与登录用户数较小的设备有关的代码就白白占用了资源。说到这里，有些读者可能发现了一个新问题，那就是支持不同设备登录的微服务里，还有很多共性的功能，比如填写验证码、找回密码等功能，在这些微服务里，几乎是一模一样的，那么每个微服务都去开发一套填写验证码和找回密码功能，显然是不合理的，这个时候，“填写验证码”变成了“一件事”，“找回密码”变成了另外“一件事”，这两件事情也需要被拆分出来，变成独立的微服务，供各种登录微服务调用。由此可见，如何划分“一件事”，这个问题还是比较复杂的，相比本地应用，Web应用的划分方式会更加复杂。本地应用在做出合理的模块划分之后，在应用的整个生命周期中可能都不会再做改变，而Web应用的划分合理性是相对的，在生命周期的不同阶段，会有不同的最适划分方式，在这个问题上，传统的应用模块划分经验不会有太多帮助，后面我们会在“AKF扩展立方”中进一步讨论这个问题。

### 理念二：优先考虑协作

在程序的设计初期就要考虑协作，即程序必须能够与其他程序进行拼接组合。假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的，同时在输入输出方面，尽可能使用简单的、文本化的、面向流的格式，因为如果程序不采用简单的文本流做输入和输出，它们就极难衔接。文本流界面的简洁性加强了程序的封装性，充当了优秀的阻隔点，防止程序的实现细节彼此泄露。不管在程序内部，使用了怎样的数据类型和数据结构，数据之间有多么复杂的逻辑关系，在将它们输出的时候，都将被转换为文本流，这个文本流在作为另一个程序的输入时，该程序可以按照自己的数据组织方式将文本流转换成特定的数据类型和数据结构，并形成自己的逻辑关系，所有这些都可以与输出程序无关。这样一来，两个程序的内部状态就被完全隔离了，而许多精致的进程间通讯方式，比如远程过程调用，都存在牵扯过多各程序内部状态的倾向。支持丰富数据类型和数据结构的远程过程调用方式，迫使两端的程序严格匹配数据类型和数据结构，极易造成匹配错误或者版本不兼容等问题，而使用二进制格式传递数据，则让接口变得更加晦涩和难以使用。

https://martinfowler.com/articles/distributed-objects-microservices.html

Web应用开发领域也经历了类似的



http://www.infoq.com/cn/articles/roa-rest-of-rest

### 理念N：C13复杂度


### Declarative


https://www.domenkozar.com/2014/03/11/why-puppet-chef-ansible-arent-good-enough-and-we-can-do-better/

### Choreography

http://www.infoq.com/cn/news/2008/09/Orchestration
http://stackoverflow.com/questions/4127241/orchestration-vs-choreography

### 12 Factor


### HATEOAS


## 原则

### C4 SPOT原则

### AKF扩展立方


## 定律

### 定律一：侯世达定律

道格拉斯·理查·郝夫斯台特（Douglas Richard Hofstadter），美国印第安纳大学文理学院认知科学教授，主要研究领域包括意识、类比、艺术创造、文学翻译以及数学和物理学探索，侯世达是他的中文名。这位看起来和软件行业关系不大的学者（他本人也说“对计算机没有兴趣”），其普利策奖著作《哥德尔、埃舍尔、巴赫》中的一句格言却在软件行业广为流传，这句格言被称为侯世达定律（Hofstadter's law）：

>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。

侯世达定律指出完成复杂任务需要花费的时间总是很难预计。这个定律经常被软件开发人员提起，特别是在进行项目计划的讨论时。定律使用自指方式（或者说是递归）表述了即使充分意识到了任务的复杂性，仍然难以准确预计完成任务所需时间的窘境。

即使使用微服务模式开发你的应用，侯世达定律依然有效，因为在评估开发所需时间的时候，你已经将微服务模式带来的效率提高考虑在内了，不是吗？

### 定律二：90-90定律

90-90定律（ninety-ninety rule）是软件行业又一个有名的定律，源自贝尔实验室专家汤姆·卡吉尔（Tom Cargill）的一句玩笑话：

>前90%的代码要花费90%的开发时间，剩余的10%的代码要再花费90%的开发时间。

合计180%的时间总量用看似荒诞的方式指出了软件项目的一个顽疾——项目完成时间常常大幅超出预期。这个定律体现了在评估软件项目完成时间的时候，对简单任务和困难任务的时间分配太过粗糙的问题，也揭示了很多项目被迫延期的原因：最后10%的工作的难度，是前90%工作的难度的9倍（如果不是10倍的话）。

### 定律三：布鲁克斯定律

是的，这个布鲁克斯就是IBM System/360系统之父和软件工程著作《人月神华》的作者弗雷德·布鲁克斯（Fred Brooks）。布鲁克斯定律（Brook's Law）的内容是：

>给一个延期的项目增加人手会使它拖得更久。

弗雷德·布鲁克斯在《人月神话》中提出了这一定律，并对其成立的原因做出了如下解释：

1. 新加入项目的人员需要学习一段时间才会有产出，教会他们反而会占用团队中老成员的时间。
1. 人员数量增加，沟通成本也会增加，最糟糕的情况下是指数级增加。
1. 任务的有限可分性：一些任务不可分割，增加人手不能使任务完成的更快。

那项目延期了怎么办？弗雷德·布鲁克斯给出的办法是：降低项目目标。

### 定律四：埃托雷观察

埃托雷观察（Ettorre's Observation）的内容是：

>另外一条路看起来会走得更快。

软件项目中存在大量的路径选择问题，大到选择一个技术方向，小到选择一个具体问题的解决方式，当我们在已选的路径上遇到障碍时，经常会觉得之前如果选择另一条路径，事情会更加顺利。这种想法经常会导致个人的犹豫不决和团队成员之间的不信任，最终影响项目的整体进度。然而另一条路径很可能只是看起来更加顺利而已，因为你在实践当前路径，对当前路径中会遇到什么困难有着更多的了解，而另一条路径仅存于你的想象之中，你“幻想”它好的一面，却不了解它坏的一面。如果你真的切换到另一条路径，八成你又会觉得之前那条路径会更加顺利，这就是“埃托雷观察”，永远的“另外一条路看起来会走得更快”。

所以，在软件项目中，做路径选择的时候要充分验证，一旦确定路径，就不要因为遇到的困难而犹豫不决。

### 定律五：康威定律




 