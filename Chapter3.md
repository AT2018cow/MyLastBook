# 理念、原则、定律与微服务设计

当我们谈及理念的时候，一般指期望按照某个理想的方式做事，而执行过程中，则有可能因为各种客观因素的限制，导致这种期望无法达成；而原则则不同：原则是必须达成的理念，在执行过程中，需要设立规章制度、流程、工具链等措施，确保原则可以达成。在实际工作中，明确理念和原则的区别至关重要：达成理念，会带来好的结果，应该奖励，不能达成，也不是什么太大的问题，下次再努力即可；遵守原则，是分内之事，违反原则，会带来坏的结果，应该惩罚。当然，结果的好坏，是个相对的概念，与投入的时间、资本、人员等诸多因素有关，某种意义上，一个组织的进步，就是把优秀的理念逐渐变成原则的过程。

在实际工作中，理念可以是感性的和鼓舞人心的，而原则则必须是：

* 措辞明确的：必须明确阐述该怎样做和达到什么样的目标，以作为实际工作的指导方针；
* 现实可达的：必须是在付出一定努力之后可以实现的，制定难以实现的原则，除了不具备指导实践的意义之外，还可能会打击团队士气；
* 可度量的：必须是量化的，实际工作中，不能只说“接口简洁”，还要将简洁的程度加以量化，例如，“接口数量小于m个”、“参数数量小于n个”、等等；
* 可检验的：实际工作中，如果提出原则，那么必须对原则的达成情况进行检验，不能检验达成情况的原则只是空谈；

与原则相关的另一个概念是定律（也称法则），人们经常混淆这两个概念，尤其是在翻译文章中。实际上，原则和定律是两个完全相反的概念，原则是“经过一定努力可以达到的”，定律是“经过再多努力也难以违背的”。定律一般会陈述一种“宿命般”的现象，也可能是一个假言命题：如果你的状况不幸落入假言命题的前件，那么绝大多情况下，你将面对该假言命题的后件所描述的糟糕结局。

下文我们会介绍一些与微服务开发密切相关的理念、原则和定律。

## 理念

早期的操作系统进程生成代价昂贵，缺乏灵活易用的进程控制机制。例如上个世纪七、八十年代广为流行的VAX VMS系统，启动进程开销极大、速度缓慢并且需要特别的权限，同时，这类操作系统缺乏灵活的进程间通讯机制，难以通过多个进程的协作实现应用功能，这些问题迫使开发者编写怪物般的巨大单体应用，将越来越多的功能和特性塞入单个程序之中，久而久之，怪物般的应用像怪物般失控，或者因不堪重负而内部崩溃。Unix操作系统的出现，带来了低价的进程生成能力和简便的进程间通讯机制，使得编写多个功能单一的小程序，并通过管道和过滤器彼此协作、组成一个均衡系统成为可能。

Unix致力于降低进程生成的开销、提供多种方法简化进程间通讯、并提倡使用能够由管道和套接字传递的简单、透明的文本格式数据，从而鼓励开发者将大型程序分解成多个协作进程，鼓励每个进程“做单件事并做好”的设计风格，从而使大型程序结构简单、功能强大、且稳定可靠。这就是Unix最具特点的模块化程序设计方法，在历史上被称为“多道程序设计”。随着Unix的流行，这种编程方式成为开发复杂应用的默认方式，以至于时不时的出现这样的笑话：

>Unix新手：“我关闭了音乐播放器，为什么音乐还在响？”
>Unix老手：“你关闭的只是播放器的图形界面，并不是播放器的引擎。”
>Unix新手：“……”

发生这样的事情，显然是因为播放器的界面和后端的解码器是两个进程，通过进程间通讯机制彼此协作，共同完成一个完整的音乐播放器功能。这种设计很多好处，例如：

1. 开发者可以开发多个不同风格的界面，并且很容易的将一个界面换成另外一个。
1. 开发者可以调用不同的后端解码器，以支持不同的音频格式，引入新的音频格式，或者换掉现有的解码器，也非常简单。
1. 社区已经有很多成熟的解码器，拿来用即可，使得播放器的开发变得非常简单。
1. 界面与解码器可以使用不同的语言开发，即可以用最适合的语言开发各个独立的程序模块。

当然，一个设计良好的音乐播放器，在图形界面被关闭的时候，是可以发消息通知后端的解码器将自己关闭的（或者也可以使用现代Unix的Init系统配置进程依赖关系，将图形界面和后端程序同时关闭）。但是即使不是这样，在Unix世界生存的人们也对其习以为常，可见这种开发模式的普遍性。即使是到了今天，当你在OS X的终端应用里退出Shell的时候，终端应用的图形界面也不会随之关闭，不是吗？

平价的进程生成和简单的进程控制对多道程序设计至关重要，可惜多年以后，Java语言开始流行，JVM屏蔽了底层操作系统的差异，开发者在大多数时间只要和JVM打交道，即可完成手头的工作，操作系统变得无足轻重，操作系统的优秀机制对软件开发带来的便利性也逐渐淡出开发者的视线。遗憾的是，JVM并没有提供类似Unix的进程管理和通讯能力，使得开发者再次倾向于编写怪物般的巨大单体应用，在Java应用服务器出现之后，这种情况没有得到改观，反而愈演愈烈，将多个应用运行在同一个应用服务器之上，形成了无比巨大的单一Java进程，一个微小的Bug都可能造成进程退出，而代码错综复杂的巨大单体应用，出现这种Bug的概率非常之高。这种巨大单体应用的维护成本高昂，哪怕是对其进行必要的更新也变得非常困难，这种应用就像恐龙一样，摄入的能量无法维持自身庞大的身躯，等待它的结局只能是衰亡。

曾经有段时间，业界寄希望于将类似Unix的进程控制和进程通讯能力引入JVM，但是这种工作的复杂度无异于将JVM变成一个操作系统，随着云计算、PaaS等技术的流行，业界开始试图通过另外一种途径解决问题，即微服务模式。

微服务模式提倡每个微服务专注于单一责任与功能，利用模块化的方式组装出复杂的大型应用，微服务之间默认通过REST API和文本格式的数据流通讯以彼此协作。微服务模式面对的问题和解决问题的方式都像极了Unix世界的传统理念，甚至可以认为微服务模式就是Unix多道程序设计模式在Web领域和分布式系统下的进一步扩展，难怪Unix程序员在看到业界鼓吹微服务时，不屑一顾的耸了耸肩膀：“难道不是一直都这样做的吗？”

所以在讨论微服务的设计理念时，我们有必要先回顾一下Unix多道程序设计所提倡的一些理念。技术人员似乎都不愿意回顾历史，尤其是，软件行业的历史只有短短的几十年，回顾如此短暂的历史，似乎远没有展望充满无限可能的未来更加有趣，所以软件行业重复的犯错，有道是“忘记过去的人注定要重蹈覆辙”。

### 理念一：做单件事并做好

程序应该只做一件事并将其做好（Do One Thing and Do It Well），“只做一件事”指的是程序的功能要单一，如果要实现多个功能，那就编写多个程序，提倡“制作多把专用的刀，而不是一把瑞士军刀”，“将其做好”指的是日后程序都要围绕这个单一功能进行优化。这个理念的提出者一般被认为是道格拉斯·麦克罗伊（Douglas McIlroy）。这个理念有时候也被称为模块原则，不过正如前文所述，在本章的上下文中，原则应该是措辞明确和可度量的，而什么样的事情算是“单件事”、“事情”的边界如何划分？这都需要在具体场景下才能得到明确的定义，所以我们还是将其列为理念。各位读者可能没有听说过道格拉斯·麦克罗伊，但想必一定听说过软件工业的神级人物、Unix的关键开发者、1983年的图灵奖得主——丹尼斯·里奇（Dennis Ritchie）和肯·汤普森（Ken Thompson），而道格拉斯·麦克罗伊正是这两位神级人物的领导。在1965年至1986年间，道格拉斯·麦克罗伊在贝尔实验室的计算机技术研发部门做了二十一年主管，这个部门最著名的事迹就是研发了Unix操作系统，丹尼斯·里奇和肯·汤普森正是这个部门的员工。同时，道格拉斯·麦克罗伊还被认为是Unix管道的发明人和Unix核心理念的奠基人。这个理念的原文是：

>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。

这个理念看起来很简单，可是知易行难，什么样的事情算是“一件事”、什么样的任务算是“新任务”？这和在开发什么样的应用、应用开发到了哪个阶段、应用使用者的数量等诸多因素密切相关。举例来说，开发一个在线视频网站，“登录”显然可以看作是“一件事”，如果使用微服务模式，那么可以把“登录服务”作为一个微服务来开发。随着网站规模的增长、用户数量越来越大，网站开始支持多种设备访问，比如电脑、手机、平板电脑、机顶盒等设备，还有Xbox、PlayStation等游戏机。由于来自每种设备的用户数量都十分巨大，这些设备的登录方式和登录界面又存在着较大的差异，“来自不同设备的登录”变成了此时的“一件事”，“登录服务”这一个微服务被拆分成了“电脑登录”、“手机登录”、“平板电脑登录”等多个微服务，由于几代PlayStation的系统差异较大，支持PlayStation访问的登录服务还可以进一步拆分为“PS2登录服务”、“PS3登录服务”、“PS4登录服务”等……这样做的另一个好处是，来自各种设备的登录用户数量差异巨大，例如来自手机的登录用户数可能是来自PlayStation 3的登录用户数的数十倍、来自PlayStation 2的登录用户数的上百倍，如果把对多种设备登录的支持都放在一个微服务里，那与登录用户数较小的设备有关的代码就白白占用了资源。说到这里，有些读者可能发现了一个新问题，那就是支持不同设备登录的微服务里，还有很多共性的功能，比如填写验证码、找回密码等功能，在这些微服务里，几乎是一模一样的，那么每个微服务都去开发一套填写验证码和找回密码功能，显然是不合理的，这个时候，“填写验证码”变成了“一件事”，“找回密码”变成了另外“一件事”，这两件事情也需要被拆分出来，变成独立的微服务，供各种登录微服务调用。

由此可见，如何划分“一件事”，这个问题还是比较复杂的，相比本地应用，Web应用的划分方式会更加复杂。本地应用在做出合理的模块划分之后，在应用的整个生命周期中可能都不会再做改变，而Web应用的划分合理性是相对的，在生命周期的不同阶段，会有不同的最适划分方式，在这个问题上，传统的应用模块划分经验不会有太多帮助，后面我们会在“AKF扩展立方”中进一步讨论这个问题。

### 理念二：协作优先，文本通讯

在程序的设计初期就要考虑协作，即程序必须能够与其他程序进行拼接组合。假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的，同时在输入输出方面，尽可能使用简单的、文本化的、面向流的格式，因为如果程序不采用简单的文本流做输入和输出，它们就极难衔接。首先文本格式对不同的操作系统和编程语言是一致的，即“天然支持异构系统集成”，其次文本流接口的简洁性加强了程序的封装性，充当了理想的阻隔点，防止程序的实现细节彼此泄露。不管在程序内部，使用了怎样的数据类型和数据结构，数据之间有多么复杂的逻辑关系，在将它们输出的时候，都将被转换为文本流，这个文本流在作为另一个程序的输入时，该程序可以按照自己的数据组织方式将文本流转换成特定的数据类型和数据结构。这样一来，两个程序的内部状态就被完全隔离了，而许多精致的进程间通讯方式，比如远程过程调用（RPC），都存在牵扯过多各程序内部状态的倾向。远程过程调用提供多种数据类型和数据结构，调用两端的程序需要对数据类型和数据结构进行匹配，容易产生匹配错误或者版本不兼容等问题，如果使用二进制格式传递数据，则会让接口变得更加晦涩和难以使用。

使用文本流接口还有一个潜在益处，那就是迫使开发者设计粗粒度的接口。一般情况下开发人员倾向于设计细粒度的接口，例如想要查询五十件商品的价格和库存，那就分别查询每一件商品的价格和库存，再重复五十次，这在进程内没有问题，但是如果是跨进程的调用，则最好将其转化成一次性的批量调用，一次性的获得这五十件商品的价格和库存，尤其是在这种调用要经过网络的时候。因为进程内的调用速度很快而且调用总是成功（指调用本身不会失败，而不是其他的程序错误），而跨进程的调用速度则慢了很多，如果是经过网络的跨主机调用，则会慢几个数量级，由于网络连接可能出现故障，调用可能失败，如果使用细粒度的接口，错误的恢复和脏数据的清理也会比较麻烦。

Web应用开发领域也经历了类似的过程，早期的二进制RPC使用者寥寥，随后出现的XML-RPC将RPC和Unix对文本流的坚持以一种有趣的方式融合到一起，将调用编码为XML，并通过HTTP协议传输，综合了RPC和文本流的优点，开始获得了比较广泛的应用。XML-RPC在获得了初步的成功之后，开始不断的引入新功能，慢慢演变成了SOAP（Simple Object Access Protocol）协议。SOAP协议有着明显的“第二系统效应”[注1]，不久之后业界便转向了更为简洁的REST模式（Representational State Transfer，表述性状态传递），并随着微服务一起发扬光大。

注1：第二系统效应指的是，在一个小型、优雅的系统获得成功之后，人们开始对这个系统的第二个版本产生了过多的期待、引入了过多的功能和假设，即“过度设计”，导致系统过于庞大和复杂，并因此而失败）。

在微服务“思潮”的早期，来自微软的Juval Löwy曾提出：“服务通过类似Unix管道（Unix-like pipelines）的方式拼接组合，复杂的服务被抽象为简单的URI接口（Uniform Resource Identifier，统一资源标识符）。”那么现在REST模式就是Juval Löwy所说的Unix-like pipelines。需要注意的是，REST模式只是一种设计风格，而不是与XML-RPC和SOAP对等的协议，REST模式将对服务的调用抽象为对资源的操作，使用URI标识资源，使用JSON、YAML等文本流表述和传递资源状态，使用GET、PUT、POST、DELETE等标准的HTTP方法操作资源。REST模式没有一个正式的标准，但是却有一套复杂而完备的理念，后面我们会对其进行单独的讨论。

### 理念三：不要传播错误

程序在发生错误的时候不应该有不可知的行为，更不应该传递混乱的信息，影响与之协作的其他程序 。最理想的情况当然是能够应付非正常的操作，但是如果在不能应付的情况下，却不声不响的继续执行，埋下隐患，或者将错误继续传递给后端，直到很久以后才显现出来，则是最坏的一种情况。尤其是在微服务模式下，一个业务功能经常由多级微服务调用共同完成，如果错误在调用链中逐级积累，容易引起雪崩效应，小错误变成大范围的故障。因此，程序要尽可能的应付错误的输入和自身的运行错误，并且在不能应付的情况下及时终止，并输出详细的错误信息以供排错。不要将错误继续传递到调用链的下一环节。

在微服务模式下，除了小心翼翼的编写代码之外，还需要提供一些必要的机制进行故障隔离，防止错误传播。典型的机制有：

* 限流：当突发的请求高峰到来时，需要有限流机制防止处理能力耗尽。如果后台还有空闲资源，系统可以趁这个机会创建更多的微服务实例，提高处理能力，再将限流停止。除了突发的请求高峰之外，程序Bug、硬件故障和缓存失效等原因，也会使微服务的处理能力突然下降，触发限流。在微服务模式下，限流之所以非常重要，是因为被调用方的不可用，很可能会造成调用方的不可用，并在调用链上逐级放大，引起服务雪崩。常见的限流方式有直接拒绝服务、排队等待、直接返回默认数据等，还有控制重试的时间间隔、尽量避免同步调用等辅助措施。
* 降级：与限流相比，降级更贴近于业务层面。降级指关闭部分业务功能，以保障主体业务功能可用。降级的原因可能是业务高峰时资源不足，需要通过关闭非核心业务功能，为核心业务功能腾出资源，以保障核心业务功能可用；也可能是后台微服务发生故障，导致与其相关的业务功能被迫关闭。例如，除夕夜大家都在微信上抢红包，这时候微信钱包的一些功能，如微粒贷、理财通和生活缴费，可能就会被关闭，因为很少有人会在这个时候去贷款、买理财产品和缴水电费；再例如，在线商店在某个支付渠道发生故障时，可以直接将这个支付渠道对应的菜单置灰，用户可以选择其他的支付渠道继续购物，此时如果不对支付功能做降级处理，就会导致整个支付功能无法使用，用户就无法愉快的买买买了。
* 熔断：熔断机制类似电路断路器，电路断路器在电路发生过载或者短路的时候自动切断电路，以保护电路上的电器不被损坏，熔断机制则在微服务过载或者网络连接缓慢的时候中断请求的进一步进入，以防止请求堆积导致资源耗尽，引发雪崩效应。设计良好的熔断机制还可以提供故障检测能力，在故障恢复的时候自动终止熔断。

实践中，上述三种机制经常需要配合使用，其根本目的都是为了进行故障隔离、防止错误传播。Netflix Hystrix就是一个同时提供这三种机制的优秀开源项目，在本书的第五章会对其进行详细的介绍。

上面回顾了古老的Unix多道程序设计中与微服务关系最为密切的三个理念，并在微服务模式下对其进行了扩展，接下来的几个理念则与微服务诞生于同一时代。

### 持续交付

持续交付（Continuous Delivery）旨在更加密集的构建、测试和发布软件，密集到如果业务需要，则每一次修改都可以即时发布到生产环境。这么做的目的是：

* 降低交付风险：由于每次只交付较小的更新，出现错误的可能性也较小，即使出现错误，也可以及时修复或者将更新回滚。
* 及时验证开发结果：开发完成并不意味着真的完成，交付到生产环境并且可用，才意味着真的完成。
* 及时获得用户反馈：每个较小的更新都可以及时被用户使用，并获得反馈信息，从而及时确认每个更新的业务价值，及时调整接下来的开发投入，获得更好的业务敏捷性。

微服务模式极大的促进了持续交付理念的实践。单体应用由于以下原因，极难进行持续交付：

* 编译时间过长：意味着很难为每一次更新都做编译。
* 测试流程复杂：更新之后要对整个应用进行全面测试，因为一次较小的更新而执行全面测试，投入产出比太低。
* 部署开销过大：类似于上一个原因，因为一次较小的更新就把整个应用重新部署一次，业务风险很大。

但是微服务模式成功的避免了上述问题：

* 微服务的代码规模较小，可以快速完成编译。
* 微服务的功能内聚性较强，测试开销较小，也容易自动化。
* 微服务易于部署，而且微服务都是采用多实例方式部署，可以先更新小部分实例，即金丝雀发布[注2]，测试通过后再将其他实例逐个更新，业务风险较小。

注2：金丝雀发布（Canary Release）指在真实的生产环境下对更新进行小范围测试，如果测试通过则进行大范围更新，如果测试失败则将小范围的更新回滚到上一个版本。这么做的意义在于可以发现测试环境中不容易发现的问题，同时将问题限制在一个较小的范围。金丝雀发布这个名称的由来是，早期矿工下矿井的时候都会带着一只金丝雀，如果矿井中出现有毒气体，金丝雀会首先察觉，为矿工创造逃脱时间。

### 不可变服务器


### Declarative

https://www.domenkozar.com/2014/03/11/why-puppet-chef-ansible-arent-good-enough-and-we-can-do-better/

### Choreography

http://www.infoq.com/cn/news/2008/09/Orchestration
http://stackoverflow.com/questions/4127241/orchestration-vs-choreography

### 12 Factor

### 翻译文章

### HATEOAS

http://www.infoq.com/cn/articles/roa-rest-of-rest

## 原则

### C4 SPOT原则

### AKF扩展立方

## 定律

### 定律一：侯世达定律

道格拉斯·理查·郝夫斯台特（Douglas Richard Hofstadter），美国印第安纳大学文理学院认知科学教授，主要研究领域包括意识、类比、艺术创造、文学翻译以及数学和物理学探索，侯世达是他的中文名。这位看起来和软件行业关系不大的学者（他本人也说“对计算机没有兴趣”），其普利策奖著作《哥德尔、埃舍尔、巴赫》中的一句格言却在软件行业广为流传，这句格言被称为侯世达定律（Hofstadter's law）：

>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。

侯世达定律指出完成复杂任务需要花费的时间总是很难预计。这个定律经常被软件开发人员提起，特别是在进行项目计划的讨论时。定律使用自指方式（或者说是递归）表述了即使充分意识到了任务的复杂性，仍然难以准确预计完成任务所需时间的窘境。

即使使用微服务模式开发你的应用，侯世达定律依然有效，因为在评估开发所需时间的时候，你已经将微服务模式带来的效率提高考虑在内了，不是吗？

### 定律二：90-90定律

90-90定律（ninety-ninety rule）是软件行业又一个有名的定律，源自贝尔实验室专家汤姆·卡吉尔（Tom Cargill）的一句玩笑话：

>前90%的代码要花费90%的开发时间，剩余的10%的代码要再花费90%的开发时间。

合计180%的时间总量用看似荒诞的方式指出了软件项目的一个顽疾——项目完成时间常常大幅超出预期。这个定律体现了在评估软件项目完成时间的时候，对简单任务和困难任务的时间分配太过粗糙的问题，也揭示了很多项目被迫延期的原因：最后10%的工作的难度，是前90%工作的难度的9倍（如果不是10倍的话）。

### 定律三：布鲁克斯定律

是的，这个布鲁克斯就是IBM System/360系统之父和软件工程著作《人月神华》的作者弗雷德·布鲁克斯（Fred Brooks）。布鲁克斯定律（Brook's Law）的内容是：

>给一个延期的项目增加人手会使它拖得更久。

弗雷德·布鲁克斯在《人月神话》中提出了这一定律，并对其成立的原因做出了如下解释：

1. 新加入项目的人员需要学习一段时间才会有产出，教会他们反而会占用团队中老成员的时间。
1. 人员数量增加，沟通成本也会增加，最糟糕的情况下是指数级增加。
1. 任务的有限可分性：一些任务不可分割，增加人手不能使任务完成的更快。

那项目延期了怎么办？弗雷德·布鲁克斯给出的办法是：降低项目目标。

### 定律四：埃托雷观察

埃托雷观察（Ettorre's Observation）的内容是：

>另外一条路看起来会走得更快。

软件项目中存在大量的路径选择问题，大到选择一个技术方向，小到选择一个具体问题的解决方式，当我们在已选的路径上遇到障碍时，经常会觉得之前如果选择另一条路径，事情会更加顺利。这种想法经常会导致个人的犹豫不决和团队成员之间的不信任，最终影响项目的整体进度。然而另一条路径很可能只是看起来更加顺利而已，因为你在实践当前路径，对当前路径中会遇到什么困难有着更多的了解，而另一条路径仅存于你的想象之中，你“幻想”它好的一面，却不了解它坏的一面。如果你真的切换到另一条路径，八成你又会觉得之前那条路径会更加顺利，这就是“埃托雷观察”，永远的“另外一条路看起来会走得更快”。

所以，在软件项目中，做路径选择的时候要充分验证，一旦确定路径，就不要因为遇到的困难而犹豫不决。

### 定律五：康威定律

